day08(java 6일차)
복습 -> 이중 반복문 -> 배열 -> 2차원배열

260109 한컴타자연습
한타 : 현대시_정지용
영타 : Serenade

0. 복습
1) 제어문
	프로그램 흐름을 제어하기 위해 사용
	조건문	if, switch
	반복문	for, while, do~while
	기타제어문	break, continue

2) 조건문
if	조건식의 결과가 true일 때만 실행

	if (조건식1){
		조건식1이 true일 때 실행문1;
	}else if(조건식2){
		조건식1이 false이고 조건식2가 true일 때 실행문2;
	}else if(조건식3){
		조건식1, 조건식2가 false이고 조건식3이 true일 때 실행문3;
	}else{
		위의 조건식1, 2, 3이 모두 false일 때 실행문;
	}

switch	값에 따라 분기처리
	가능한 타입 : byte, short, int, char, String, enum(나중에 배움)
	
	switch(변수){
	case 값1:
		실행문1;
		break;
	case 값2:
		실행문2;
		break;
	...
	default:
		위에 값이 일치하는 것이 없을 때 실행문;
		break;
	}

	switch(변수){
	case 값1 -> 실행문1;
	case 값2 -> 실행문2;
	...
	default -> 실행문;
	}

3) 반복문
for	반복횟수나 범위가 정해져있을 때 사용
	for(초기식; 조건식; 증감식){
		실행문;
	}

	초기식
	조건식
	조건식이 true면 실행문
	증감식
	조건식 다시 확인 ... 계속 반복
	조건식이 false면 반복문 탈출
	
while	조건을 먼저 검사 -> 참인 경우 반복실행
	false가 되는 경우를 만들지 않으면 무한루프(무한반복)된다
	
	while(조건식){
		실행문;
	}

do ~ while	무조건 1번은 실행 후 조건 검사 -> 참인경우 반복실행
	
	do {
		실행문;
	} while(조건식);

4) 기타제어문
break	반복문이나 switch문을 즉시 종료
	break문을 만나면 반복문 전체를 즉시 빠져나감

continue	현재 반복만 건너뛰고 다음 반복으로 이동
		반복문을 완전히 종료하지 않음

int num = 1;
while(num < 5){ //4번 반복
	if(num == 3){
		num ++;
		continue;
	}
	syso(num);
	num ++;

}

[실행결과]
1
2


1. 이중 반복문
	반복문 안에 또 다른 반복문이 들어간 구조
	하나의 반복문이 실행되는 동안 그 안에 있는 반복문이 여러번 반복 실행되는 구조

1) 문법
	for(초기식 int i = 0; 조건식; 증감식){		//바깥for문
	   for(초기식 int j = 0; 조건식; 증감식){	//안쪽for문
		실행문
	   }
	}
	
	바깥 for문이 1번 실행될 때 안쪽 for문 처음부터 끝까지 전부 실행
	그다음 바깥 for문의 증감식으로 올라가서 조건식 비교 

행 => 바깥 for문
열 => 안쪽 for문

	1	2	3
	4	5	6
	//2행 3열 구조
	//행은 바깥for문에서 만든다

	for(int i = 0; i < 2; i++){
		// syso(i)		
		for(int j = 0; j < 3; j++){
			//syso(i + " " + j)
			System.out.print(i + " " + j + "\t");
		}
		System.out.println();
	}


바깥for문
초기식	int i = 0;
현재i의 값	조건식		실행문	현재j값	조건식	실행문	j증감식	i증감식
i = 0		0 < 2	true	i=0	j=0	0<3 true 0	0+1 1
i = 0					j=1	1<3 true 1	1+1 2
i = 0					j=2	2<3 true 2	2+1 3
i = 0					j=3	3<3 false		0+1 1
i = 1		1<2 true	i=1	j=0	0<3 true
					j=1
					j=2
					j=3				2
i = 2

현재 출력된 것
0
0
1
2
1
0
1
2

0 0
0 1
0 2
1 0
1 1
1 2

0 0	0 1	0 2
1 0 	1 1 	1 2

2) 사용 예시
- 표형태의 데이터 : 행이 있고 각 행마다 열이 있을 때
	1 2 3
	4 5 6
	행 : 바깥 반복문 / 열 : 안쪽 반복문

- 행 / 열 구조 
	좌석 배치
	좌표(x, y)
	시간표

- 구구단
	단(2단, 3단, ... 9단) -> 바깥 반복문
	곱해지는 수(1, 2, 3, ... 9) -> 안쪽 반복문

- 별 출력
	줄 수 -> 바깥 반복문
	한줄에 찍히는 별의 개수 -> 안쪽 반복문

3) 이중 for문과 이중 while문
	이중for문		이중while문
구조	간결		복잡
초기화	자동		직접작성
사용	대부분에서 사용	조건기반시 사용

2. 배열(Array) : 저장공간의 나열
	변수를 여러개 선언하면 이름(변수명)도 여러개 생긴다 -> 각 저장공간을 관리하기 불편하다
	n칸짜리 배열을 선언하면 저장공간이 여러개 생기고, 이름은 한 개 생긴다 -> 관리하기 편하다
	규칙성이 없는 값에 규칙성을 부여하기 위해서(index)

변수 []	: 하나의 타입으로 된 하나의 값만 저장할 수 있는 저장공간
배열 [][][][] : 하나의 타입으로 된 여러 값을 저장할 수 있는 저장공간

1) 배열의 선언
	변수 선언		자료형 변수명 = 값;

- 배열 변수를 선언 후 배열 생성
  어떤 값을 넣을지 모르나 몇 칸 만들지는 알 때 사용

	자료형[] 배열명 = new 자료형[배열크기];
	ex) int[] ar1 = 1;	//어떤값을 넣을지 모르지만 5칸짜리가 필요하다

- 배열 변수 선언과 동시에 초기값 할당
  어떤 값을 넣을 지 알 때 사용
	
	자료형[] 배열명 = {값1, 값2, 값3};
	ex) int[] ar2 = {100, 20, 50};

- 배열을 생성하지 않고 배열 변수 초기화
  어떤값을 넣을지도 모르고, 몇칸짜리로 만들어야할지도 모를 때 사용
	
	자료형[] 배열명 = null;
	ex) int[] ar3 = null;

- 배열 변수에 배열 생성과 초기화
	
	배열명 = new 자료형[]{값1, 값2, 값3};
	ex) ar3 = new int[]{10, 20, 30, 40};



+) 배열 선언 VS 배열 생성
	두 단계!!

배열변수 선언
	자료형[] 배열명;

배열생성
	배열명 = new int[4];


자료형[] 배열명 = new int[배열크기]; 

자료형[] 배열변수 = null;
.....
배열변수 = new int[]{10, 20, 0, 0};
	선언과 생성을 따로 관리할 수 있게 된다

+) JVM의 메모리 영역(Runtime Data Area)
	JVM이 프로그램을 실행하는 동안 사용하는 메모리 영역
	JVM의 메모리 영역은 OS(운영체제)에게 할당받은 메모리이다
	운영체제로부터 할당받은 메모리 공간 내에서 독자적으로 메모리를 관리하고 이를 여러 영역으로 나누어 사용한다
	따라서 JVM의 메모리 영역은 운영체제의 메모리 영역과는 분리되어 동작된다
	크게 5개의 영역으로 구분되며 힙영역, 스택영역, 메소드영역, 프로그램 카운터 레지스터, 네이티브 메소드 스택으로 나뉜다

- 스택영역(Stack Area)
	메소드 호출(사용)시에 사용하는 메모리 공간
	메소드가 호출될때마다 스택에 새로운 프레임이 생성되며 메소드 종료시에는 해당 프레임이 제거된다
	각 쓰레드마다 별도의 스택영역을 가지며 동시에 여러 메소드가 호출될 수 있다

- 힙영역(Heap Area)
	객체와 배열이 생성되는 메모리 공간
	new 연산자로 생성되는 객체나 배열이 할당된다
	동적 메모리 할당을 사용하기 때문에 프로그램이 실행중에 메모리의 크기를 동적으로 조정할 수 있다

- 메소드영역(Method Area)
	클래스의 정보, static 변수, 상수 등이 저장되는 메모리 공간
	메소드 영역은 JVM이 시작될 때 생성되며 모든 쓰레드가 공유한다

- 프로그램 카운터 레지스터(PC register)
	현재 실행중인 명령어의 주소를 저장하는 메모리 공간
	JVM이 쓰레드를 생성할 때마다 별도의 PC register를 가진다

- 네이티브 메소드 스택(Native Method Stack)
	JNI(Java Native Interface)를 사용하여 호출되는 C/C++ 메소드의 스택영역이다

2) 배열의 구조
	int[] ar	= 	new int[]{7, 9, 1, 4, 2};
	---------    대입 연산자	--------------------------
	stack 메모리		heap 메모리에 저장된 시작 주소값
    정수형배열 ar 참조변수		5칸짜리 정수형 배열을 만들고 값이 저장되어있다

	ar이라는 이름의 변수는 배열 객체의 주소값을 가리키는 참조변수이다
	배열 객체는 heap 영역에 할당되며, 배열 객체 안에는 여러개의 값이 담길 수 있다
	따라서 ar 변수는 배열 객체의 주소값을 가리키고 해당 배열 객체 안에 여러값을 가질 수 있다

	[Stack]			[Heap]
	| ar  |	------------>	|[8][2][1]|
	참조변수			배열객체

3) new
	Heap 메모리에 실제 저장공간을 할당(생성)한다

	heap 영역에 필요한 크기의 메모리 공간을 만든다
	그 저장공간의 시작 주소(참조값)를 가져온다
	그 주소를 변수에 저장한다

4) null
	아직 어떤 객체(배열)도 가리키지 않는 상태

	지금은 모르지만 나중에 어떤 주소가 들어올 예정일 때
	초기값으로 사용

5) index
	배열을 생성할 때 각각의 저장공간에 자동으로 붙여지는 번호
	0부터 순차적으로 증가하면서 부여된다
	배열의 이름이 한개이기 때문에 이름만으로는 배열의 여러 저장공간에 접근할 수 없다
	그렇기 때문에 index를 이용하여 각각의 저장공간에 접근한다
	배열명[index]로 사용하고 배열명[index]는 하나의 저장공간이기 때문에 변수처럼 사용한다

6) length
	배열을 생성할 때 자동으로 생성되는 저장공간의 수(배열의 길이)
	배열의 길이는 한 번 만들어지면 변동될 수 없으므로 length는 상수라고 볼 수 있다
	배열명.length로 사용한다

7) 배열의 사용
	배열명[index]

	int[] ar = { 5, 2, 1, 7};
	syso(ar);	// 배열의 시작 주소값(참조값)

	ar[0] = 10; 	// 저장공간
					[10][2][1][7]
	ar[0] = ar[1] + ar[0] + 2;
					[14][2][1][7]
	syso(ar[1] + 3); //값
	ar[2] += ar[0] + ar[1];
	1	14	2		[14][2][17][7]


day08_task 프로젝트 만들고 array 패키지 생성
BasicArray01_본인이름.java ~ BasicArray08_본인이름.java 파일 생성
git hub 로그인

배열 복습문제
- 배열에 값을 담아주는 반복문, 출력하는 반복문 따로 작성하기
- 로직구성 먼저!

// 패키지 : homework08
// 클래스 : ArrayTask01
1. 100~1까지의 값을 배열에 넣고 출력

// 클래스 : ArrayTask02
2. 1~10까지의 값을 배열에 넣고 총 합을 출력

// 클래스 : ArrayTask03
3. 3명의 수학점수를 사용자에게 입력받아 배열에 저장하고 평균 점수를 출력

// 클래스 : ArrayTask04
4. 0 1 2 3 0 1 2 3 배열에 담고 출력

// 클래스 : ArrayTask05
5. A ~ F까지를 배열에 값을 넣고 출력

// 클래스 : ArrayTask06
6. A ~ F까지 중 C만 제외하고 배열에 담아 출력

// 클래스 : ArrayTask07
7. aBcDeFgHiJkLmNoPqRsTuVwXyZ 배열에 담고 출력(char만 사용, 선언없이)

// 클래스 : ArrayTask08
8. 5개의 정수를 입력받은 뒤 그 값을 배열에 담고 최대값과 최소값 출력







	
//6번 클래스명 : AtmTest
6. ATM 메뉴에서 입금, 출금, 잔액조회 하기
	[조건]
	초기 잔액은 10000원으로 설정
	메뉴 선택에 따라 작업 수행
	종료시 프로그램 종료
	숫자(번호)로 입력받기

	String msg ="\nATM 기기의 메뉴 중 번호를 선택하세요."
		+ "\n1. 잔액조회"
		+ "\n2. 입금"
		+ "\n3. 출금"
		+ "\n4. 종료"
		+ "\n선택 : ";
		System.out.println(msg);
	그 외의 번호 입력시 다시 선택하세요 출력 후 메뉴 보이기
	번호 입력시 해당 메시지만 출력

//7번 클래스명 : SingTest
7. 코인 노래방 시스템을 구현하는 개발자입니다.
사용자로부터 금액을 입력받아 부를 수 있는 곡 수와 잔돈을 계산하고, 음료를 마실 수 있는지 여부도 안내하는 프로그램

[요구사항]
사용자에게 곡 당 가격을 입력받는다.
반복문을 사용하여 사용자에게 금액을 계속 입력받는다.
단, 0을 입력하면 프로그램은 종료된다.
입력받은 금액으로 부를 수 있는 곡 수와 잔돈을 출력한다.
곡 수 : 금액 ÷ 곡당 가격
보너스 : 5곡당 1곡 보너스 (예: 5곡 → 6곡, 10곡 → 12곡)
잔돈 : 금액 % 곡당 가격
음료(100원)를 마시고 싶다면, 음료 가격을 차감하고 노래를 줄이는 방식으로 대체 제안을 출력한다.
사용자에게 "음료를 구매하시겠습니까?" 라고 묻고
YES를 입력하면 대체 결과를 출력 NO를 입력하면 원래 계산된 노래 수를 유지한다
금액이 부족할 경우, 노래를 부를 수 없다는 안내 메시지를 출력한다.

입력은 정수로 받되, nextLine()을 사용하여 입력 오류를 방지한다.
대소문자 구분해서 YES/NO 처리한다.
Scanner는 한 번만 생성하고 마지막에 .close()로 닫을 것

[입출력 예시]
곡 당 가격 입력: 300
금액 입력 (0 입력 시 종료): 1000
3곡을 부를 수 있으며 잔돈은 100원입니다
음료를 마시고 싶으면 3곡을 부를 수 있으며 잔돈은 0원입니다
음료를 구매하시겠습니까? (YES/NO): YES
음료를 구매하셨습니다.
3곡을 부를 수 있으며 잔돈은 0원입니다
금액 입력 (0 입력 시 종료): 900
3곡을 부를 수 있으며 잔돈은 0원입니다
음료를 마시고 싶으면 2곡을 부를 수 있으며 잔돈은 200원입니다
음료를 구매하시겠습니까? (YES/NO): YES
음료를 구매하셨습니다.
2곡을 부를 수 있으며 잔돈은 200원입니다
금액 입력 (0 입력 시 종료): 900
3곡을 부를 수 있으며 잔돈은 0원입니다
음료를 마시고 싶으면 2곡을 부를 수 있으며 잔돈은 200원입니다
음료를 구매하시겠습니까? (YES/NO): NO
음료를 구매하지 않았습니다.
금액 입력 (0 입력 시 종료): 0
프로그램을 종료합니다.

















