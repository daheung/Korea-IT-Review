day08_task 과제 미제출
창훈, 재원, 준승, 진옥, 유광, 성인, 민진

day09(java 7일차)
복습 -> 2차원 배열 -> 정렬 알고리즘 -> 메소드

0. 복습
1) 제어문
조건문	
	if문, switch문
반복문
	for문, while문, do ~ while문
기타제어문
	break문, continue문

2) 이중 반복문
	반복문 안에 반복문 
	바깥 반복문 => 행
	안쪽 반복문 => 열

3) 배열(Array)
	저장공간의 나열

(1) 배열 선언
- 어떤 값을 넣을지 모르나 몇 칸 만들지 알 때
	자료형[] 배열변수 = new 자료형[배열크기];

- 어떤 값을 넣을지 알 때
	자료형[] 배열변수 = {값1, 값2, 값3};

- 어떤값을 넣을지 모르고 몇칸 만들어야할지도 모를 때
	자료형[] 배열변수 = null;

- 배열변수에 배열 생성과 초기화
	배열변수 = new 자료형[] {값1, 값2, 값3};

4) new
	heap 메모리에 실제 저장공간을 할당(생성)한다
	heap 영역에 필요한 크기의 메모리 공간을 만든다
	그 저장공간의 시작주소(참조값)를 가져온다
	그 주소를 변수에 저장한다

5) index와 length
	index : 배열 생성할 때 각각의 저장공간에 자동으로 붙여지는 번호
		0부터 순차적으로 증가하면서 부여됨
		배열명[index]
	length : 배열을 생성할 때 자동으로 생성되는 저장공간의 수(배열의 길이)
		배열명.length

1. 2차원 배열
1) 2차원 배열의 선언과 생성
	자료형[][] 배열변수 = new 자료형[행][열];
	자료형[][] 배열변수 = {{값1, 값2, 값3}, {값1, 값2, 값3}};


	1	2	3	4
	5	6	7	8
	9	10	11	12
	=> 3행, 4열

	int[][] ar1 = new int[3][4];
	int[][] ar2 = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};

2) 2차원 배열의 길이
	배열변수.length	=> 행의 길이
	배열변수[i].length => 열의 길이

3) 2차원 배열과 for문
	int[][] ar1 = new ar1[2][4];

	for(int i = 0; i < ar1.length; i++){	//행
		for(int j = 0; j < ar1[i].length; j++){ //열
			실행할문장;
		}
	}

4) 향상된 for문(for-each문)
	배열이나 컬렉션의 요소를 처음부터 끝까지 하나씩 꺼내서 처리하는 반복문
	for(변수타입 변수명 : 배열 또는 컬렉션){
		//반복실행할 코드
	}

	int[] numbers = {10, 20, 30};
	1) 배열의 첫번째 요소 10을 꺼냄
	2) 변수에 저장 -> 코드 실행
	3) 다음 요소 20을 꺼냄
	4) 변수에 저장 -> 코드 실행
	5) 마지막 요소 30을 꺼냄
	6) 변수에 저장 -> 코드 실행
	7) 더 이상 요소가 없으면 종료
	
- for-each문의 장점
	가독성 향상
	에러 감소 : 인덱스 범위 초과 오류, length 등을 이용하여 조건식을 만들 때 실수x
	컬렉션과 자주 사용

- for-each문의 한계
	읽기 전용 반복문
	인덱스 사용 불가능
	요소 삭제/수정 제한

2. 배열의 정렬
1) 정렬 알고리즘
	데이터를 정해진 순서대로 정렬하는 방법

	삽입정렬(Insertion Sort)	각 요소를 이미 정렬된 부분에 삽입
	선택정렬(Selection Sort)	전체에서 최소값을 찾아 앞자리와 교환
	버블정렬(Bubble Sort)	인접한 두 요소를 비교하며 큰 값을 뒤로 이동
	퀵정렬			분할정복방식, 실무에서 자주 사용됨
	병합정렬			리스트 합병
	힙정렬			최대/최소 힙 자료구조 사용
	계수정렬			정수범위가 작을 때 매우 빠름

+) 정렬의 목적
	데이터를 오름차순 또는 내림차순으로 나열하기 위함
	검색, 통계, 데이터 처리 효율 향상

+) 시간 복잡도(Time Complexity)
	알고리즘이 입력크기(n)에 따라 얼마나 많은 연산(시간)이 필요한지를 나타내는 개념
	실제 시간(초)이 아니라 연산 횟수의 증가 추세로 비교한다

- 시간 복잡도가 중요한 이유
	같은 문제라도 알고리즘에 따라 실행 속도 차이가 큼
	입력 크기가 커질수록 성능 차이가 극적으로 발생
	효율적인 코드 선택의 기준

- Big-O 표기법 : 입력이 매우 커질 때의 최악의 경우를 기준으로 함

표기		이름	의미		예시
O(1)		상수 시간	입력 크기와 무관	배열 인덱스 접근
O(log n)	로그 시간	반씩 줄어듦	이진 탐색
O(n)		선형 시간	입력에 비례	배열 전체 탐색
O(n log n)	선형 로그	효율적인 정렬	병합 정렬
O(n²)		이차 시간	중첩 반복문	버블 정렬
O(2ⁿ)		지수 시간	매우 느림		부분집합 탐색

- 문제마다 시간복잡도를 예상가능
	데이터 크기 제한		예상되는 시간 복잡도
	n<=1,000,000		O(n) or O(log n)
	n <= 10,000		O(n²)
	n <= 500		O(n³)

	N범위가 500인 경우 -> 시간복잡도 O(n³) 알고리즘 설계
	N범위가 2000인 경우 -> 시간복잡도 O(n²) 알고리즘 설계
	N범위가 100000인 경우 -> 시간복잡도 O(n logn) 알고리즘 설계
	N범위가 1000000인 경우 -> 시간 복잡도 O(n) or O(log n) 알고리즘 설계

- O(1)
	int[] arr = new int[3];
	int x = arr[0];

- O(n)
	for(int i = 0; i <= 3; i++){
		syso(i);
	}

- O(n²)
	for(int i = 0; i <= 3; i++){
		for(int j = 0; j <= 3; j++){
			syso(i + " " + j);
		}
	}

2) 삽입정렬
	배열을 앞에서부터 하나씩 순회하면서 이미 정렬된 부분에 현재 값을 올바른 위치에 삽입하는 방식

- 동작방식
	두번째 요소부터 시작
	앞의 요소들과 비교하면서 자신의 위치를 탐색
	해당 위치에 삽입
	끝까지 반복

- 예시
	[5, 2, 9, 1]
	-> 2를 5 앞에 삽입 [2, 5, 9, 1]
	-> 9는 그대로	[2, 5, 9, 1]
	-> 1를 맨 앞으로 삽입 [1, 2, 5, 9]

- 특징
	거의 정렬된 배열에서 매우 효율적
	안정 정렬

3) 선택정렬
	배열에서 가장 작은 값을 선택하여 현재 위치와 교환

- 동작원리
	전체에서 최소값을 탐색
	현재 위치와 교환
	다음위치에서 다시 최소값 탐색
	끝까지 반복

- 예시
	[5, 2, 9, 1]
	-> 최소값 1을 첫 위치로 [1, 2, 9, 5]
	-> 다음 최소값 2 그대로 [1, 2, 9, 5]
	-> 다음 최소값 5 	    [1, 2, 5, 9]

- 특징
	구현이 매우 단순
	교환 횟수는 적지만 비교 횟수는 많음
	불안정 정렬

초기 : [5, 2, 9, 1, 6]
i = 1, key = 2

정렬된 구간 : [5]

5 > 2 이므로 5를 오른쪽으로 이동
→ [5, 5, 9, 1, 6]

이제 key(2)를 맨 앞에 삽입
→ [2, 5, 9, 1, 6]

1단계 : [2, 5, 9, 1, 6] => 출력

i = 2, key = 9
정렬된 구간 : [2, 5]

5 > 9 ? 아니므로 이동 없음
→ 그대로 [2, 5, 9, 1, 6]
2단계 : [2, 5, 9, 1, 6] => 출력

i = 3, key = 1

정렬된 구간 : [2, 5, 9]
9 > 1 → 밀기
5 > 1 → 밀기
2 > 1 → 밀기
→ [2, 2, 5, 9, 6] 같은 중간 과정들을 거쳐 마지막에 1 삽입
→ [1, 2, 5, 9, 6]
3단계 : [1, 2, 5, 9, 6]

i = 4, key = 6
정렬된 구간 : [1, 2, 5, 9]

9 > 6 → 밀기

5 > 6 ? 아니므로 stop
key를 5 뒤에 삽입
→ [1, 2, 5, 6, 9]
4단계 : [1, 2, 5, 6, 9] => 출력


5) 버블 정렬
	인접한 두 요소를 비교하여 순서가 잘못되면 교환
	가장 큰값이 반복마다 배열의 끝으로 이동

- 동작원리
	배열을 반복적으로 순회
	인접한 두 요소 비교
	순서가 틀리면 교환(swap)
	한 번의 순회가 끝나면 가장 큰값을 정렬 완료
	정렬된 요소를 제외하고 반복

	[5, 2, 9, 1, 6]

첫번째 순회
	5 > 2	-> true 교환 -> [2, 5, 9, 1, 6]
	9 > 1	-> true 교환 -> [2, 5, 1, 9, 6]
	9 > 6 	-> true 교환 -> [2, 5, 1, 6, 9]
두번째 순회
	2 > 5	-> false 교환x	[2, 5, 1, 6, 9]
	5 > 1	-> true 교환	[2, 1, 5, 6, 9]
세번재 순회	
	2 > 1	-> true 교환	[1, 2, 5, 6, 9]

- 특징
	가장 직관적인 정렬
	안정정렬
	성능은 가장 비효율적


6) Arrays.sort(배열명)
	java.util.Arrays 클래스에 포함된 정렬 메소드
	내부적으로 TimSort 알고리즘을 사용하여 합병정렬과 삽입 정렬을 결합한 고효율 알고리즘이다
	기본적으로 오름차순으로 정렬되므로 배열을 빠르고 효율적으로 정렬할 수 있다

7) Arrays.toString(배열명)
	.toString() 배열을 내용을 문자열 형식으로 반환하는 메소드
	배열을 보기 좋게(쉽게) 출력하기 위해 사용된다
	기본적으로 1차원 배열의 내용을 출력할 수 있다

8) Arrays.deepToString(배열명)
	다차원 배열을 내용을 출력하기 위해 사용되는 메소드

3. 배열의 얕은 복사와 깊은 복사
	복사가 참조를 복사하는지 또는 실제 데이터를 복사하는지에 따라 얕은 복사와 깊은 복사로 나눌 수 있다

1) 얕은 복사(Shallow Copy)
	복사된 객체가 원본 객체의 참조를 공유한다
	원본과 복사본이 같은 객체를 참조하므로 하나를 수정하면 다른 하나에도 영향을 미친다
	배열의 경우 복사가 이루어져도 내부 요소는 복사되지 않고 참조값만 복사된다

2) 깊은 복사(Deep Copy)
	원본 객체의 데이터 자체를 복사하여 복사된 객체가 원본 객체와 독립적이다
	원본 객체를 수정해도 복사본은 영향을 받지 않는다
	배열의 경우 내부 요소를 재귀적으로 복사해야한다

+) 재귀(Recursion)
	함수가 자기 자신을 호출하는 프로그래밍 기법이다
	큰 문제를 해결하기 위해 동일한 문제를 더 작은 크기로 나누고 반복적으로 해결하는 방식으로 작동한다

-----------------------------------------------------------------------------
배열 복습

1) 배열 : 하나의 타입으로 된 여러 값을 저장할 수 있는 저장공간
2) 배열 사용 목적
	데이터의 집합을 효율적으로 관리하기 위한 목적
	데이터의 순서를 보존하기 위한 목적
	반복문을 사용하여 배열의 요소를 처리하기 위한 목적
	메모리를 효율적으로 사용하기 위한 목적
	데이터를 정렬하거나 검색하기 위한 목적
3) 배열 선언
	자료형[] 배열변수;
	자료형[][] 배열변수;

4) 배열 생성과 초기화
	배열 생성시 new 연산자를 사용
	배열을 생성하면서 값을 초기화
	
	자료형[] 배열변수 = new 자료형[배열크기];
	자료형[] 배열변수 = new 자료형[] {값1, 값2, 값3,..};
	자료형[] 배열변수 = {값1, 값2, ..};
	자료형[] 배열변수 = null;
	
5) 다차원 배열의 선언과 생성
	배열안에 또 다른 배열이 포함된 상태(행과 열)
	차원수와 각 차원의 크기를 지정

	자료형[][] 배열변수 = new 자료형[행][열];
	자료형[][] 배열변수 = {{값1, 값2, 값3},{값1, 값2}, {값1}};

	* * *
	* *
	*

+) 가변배열(비정형 배열, Jagged Array)
	각 행(row)의 길이가 서로 다른 2차원 배열을 의미
	- 자바에서 2차원 배열이 배열의 배열
	- 각 행이 서로 다른 1차원 배열을 참조할 수 있음
	자료형[][] 배열변수 = new 자료형[행][];

+) 정형배열(Rectangular Array)
	모든 행의 길이가 동일한 2차원 배열을 의미
	자료형[][] 배열변수 = new 자료형[행][열];

6) 배열의 구조
	int[]	ar		= 	new int[3];
		--------------	 	-----------
		참조변수 stack영역		참조값 heap 영역
		[첫번째 주소값]		[값1][값2][값3]
		ar			idx0 idx1 idx2

	자바 배열은 C나 C++과 달리 포인터 연산을 허용하지 않는다
	따라서 배열 요소에 접근할 때는 인덱스연산을 통해 요소에 접근해야한다
	인덱스 연산을 통해 배열 요소에 접근할 때는 배열변수의 시작주소와 인덱스 번호를 더한 값이 해당 요소의 주소가된다
	배열변수는 호출스택에 할당되며 배열변수에 저장한 값을 배열의 시작주소를 나타낸다
	
	배열 요소는 heap 메모리에 할당되므로 배열변수가 참조하는 heap 메모리 위치를 가리키는 참조변수(Reference)를
	스택(Stack) 메모리에 저장하는 것이다

7) for-each문
	코드의 가독성을 높이고 반복문에서 발생할 수 있는 일부 에러를 방지할 수 있다는 장점이 있다
	for(변수타입 변수명:배열){
		//반복실행할 코드;
	}

-----------------------------------------------------------------------------
3. 메소드1
1) 함수와 메소드
	클래스 밖에 선언되어있다면 함수라고 부르지만 클래스 내부에 선언되어있는 함수는 메소드라고 부른다
	자바에서는 모든 함수가 클래스 내부에서 선언되기 때문에 메소드만 존재한다
	
2) 메소드
	기능
	이름뒤에 소괄호
	
3) 메소드 선언과 구현(정의)
	
	리턴타입 메소드명(자료형 매개변수, 자료형 매개변수..) <- 선언부
	{					<- 구현부
		실행할 문장;
		return 리턴값;
	}

- 리턴타입 : 반환할 값이 있다면 반환값의 자료형을 작성하고 없다면 void를 작성한다
- 메소드명 : 동사로 작성한다
- 매개변수 : 외부에서 전달받을 값이 있다면 자료형과 순서에 맞게 선언해준다(자료형이 반드시 필요하다)
	생략이 가능하다(단, 생략했을 경우 외부에서 값을 받을 수 없다)
- 실행할 문장 : 생략이 가능하다, 메소드의 기능을 구현하는 코드를 작성한다
- return : 생략이 가능하며 return이 실행되면 메소드가 종료된다
	리턴값이 있다면 메소드를 사용하는 부분을 통채로 리턴 값으로 본다
	리턴값이 없다면 값이 아니다

4) 메소드의 정의와 사용
	메소드를 정의할 때는 {}중괄호가 있고 반드시 메소드 밖에서 정의한다
	메소드를 사용할 때는 {}중괄호가 없고 반드시 메소드 안에서 사용한다

5) 메소드의 정의 순서

	리턴타입 메소드명(자료형 매개변수, 자료형 매개변수..) <- 선언부
	{					<- 구현부
		실행할 문장;
		return 리턴값;
	}

(1) 기능을 생각한다(숫자를 더해주는 기능)
(2) 반환타입을 생각한다
    반환타입이 생각나지 않는다면 우선 void로 작성한다
	void
(3) 기능에 알맞은 메소드명을 작성한다(가능하면 동사로 add, sum, ..)
	void add(){}
(4) 매개변수를 생각한다(숫자 2개 => 정수형 2개)
	void add(int num1, int num2){}
(5) 구현부 => 실행할 문장을 생각한다
	void add(int num1, int num2){
		syso("num1의 값 : " + num1 + ", num2의 값 : " + num2);
		int result = num1 + num2;
	}
(6) 리턴값을 생각한다
	void add(int num1, int num2){
		syso("num1의 값 : " + num1 + ", num2의 값 : " + num2);
		int result = num1 + num2;
		return result;
	}	
(7) 반환타입을 확인하고 수정한다
	int add(int num1, int num2){
		syso("num1의 값 : " + num1 + ", num2의 값 : " + num2);
		int result = num1 + num2;
		return result;
	}

6) 메소드 호출방법 4가지 ★★★★★
	매개변수	리턴값	호출
	x	x	객체명.메소드명();
	o	x	객체명.메소드명(인수); //매개변수의 개수만큼 타입에 맞춰서 입력
	x	o	syso(객체명.메소드명());
			자료형 변수명 = 객체명.메소드명();
	o	o	syso(객체명.메소드명(인수));
			자료형 변수명 = 객체명.메소드명(인수);

+) 메소드를 정의한 후 메소드를 호출할 때 오류 나는 이유
	java 어플리케이션을 실행하면 .java 파일을 컴파일러가 해석하고 .class 파일을 만들어준다
	.class 파일을 JVM에 포함된 클래스 로더가 읽어내는데 static이 붙은 변수나 메소드를 먼저 메모리에 할당시킨다

	int addTen(int num){
		int result = num + 10;
		return result;
	}

	- 이 상태는 메모리에 올라가지 않은 상태이기 때문에 addTen이라는 메소드를 못찾아서 오류가 발생한다
	메소드를 정의할 때 static 키워드를 붙여준다

	클래스명 참조변수 = new 클래스명();
	해당 메소드가 있는 클래스를 알려준다
	참조변수명.메소드명(); 형태로 사용하면된다

1/12/월 팀과제 1일차
	팀장 groupPro01/02/03/04	깃허브 원격 저장소 생성
				링크 강사 개인 카톡으로 공유하고 강사도 초대해둘 것
	어떤 식으로 구성할 지, 팀원별 어떻게 기능 분배할 지
	기획 내용 메모장에 작성 후 (메모장 파일 명 : 팀번호_과제번호(A or B)_1차회의록) 개인 카톡으로 전달
	
팀과제1(~배열)
A. 대중교통 요금 정산	: 2팀, 4팀
	사용자가 대중교통을 이용할 때마다 교통수단과 조건을 입력하고 이용 내역을 배열에 기록한 뒤 종료 시 한번에 정산하는 프로그램

- 기능 요구사항
	교통수단 이용 입력(버스/지하철)
	[요금 규칙] 버스 기본요금 : 1200원, 지하철 기본 요금 : 1300원
	아래 조건 중 1개 이상 적용할 것
	- 청소년 할인
	- 환승 할인
	- 일정 횟수 이상 이용 시 할인
	- 특정 교통수단 이용 횟수 조건
	배열 저장 필수(한 번 이용에 배열 한 칸 사용) : 교통수단, 기본 요금, 할인 금액 또는 최종 요금
	종료 후 정산 출력 : 총 이용 횟수, 교통수단별 이용 횟수, 총 요금, 평균 요금 또는 할인 총액(선택)	
	
B. 용돈관리 & 소비 패턴 분석		: 1팀, 3팀
	사용자가 일정기간동안의 지출을 입력하면 지출 내역을 배열에 저장하고 종료 시 소비 패턴을 분석하는 프로그램

- 기능 요구사항
	지출입력 : 날짜 또는 순서 입력, 지출 항목 입력(식비/교통/쇼핑/기타), 지출 금액 입력
	지출할 때마다 배열에 저장 : 날짜 또는 순서 입력, 항목, 금액
	[분석 조건]
	아래 조건 중 최소 2개 이상 구현
	- 총 지출 금액
	- 항목별 지출 합계
	- 특정 항목이 전체의 일정 비율 이상일 경우 경고메시지
	- 지출 금액이 연속으로 증가하는 패턴 감지
	- 예산 초과 여부 판단
	종료 후 결과 출력 : 총 지출, 가장 많이 사용한 항목, 소비 습관 판단 메시지

- 공통 필수 규칙
	배열 최소 2개 이상 사용
	팀원 전원 코드 작성 필수
	각 코드 영역에 담당자 이름, 기능 주석 필수
	본인 영역 외에 수정 하면 안됨
	실행되지 않으면 안됨




















































