day15(JAVA 13일차)

**문제 구성**
- 단답형 : **3문제**
- 서술형 : **2문제**
- 코드 구현 : **3문제**

5번까지만 복사해서 아래칸에 붙여넣은 후 작성
6, 7, 8번은 이클립스에서 java project 만들고 진행
   java project명 : ncs01_본인이름
   패키지명 : ex06_본인이름, ex07_본인이름, ex08_본인이름
   6번 클래스명 : Ex06
   7번, 8번 클래스명 : 문제 제시

문제 1. 괄호 안에 들어갈 알맞은 용어를 작성하시오. 
(1) 메소드 선언 시 괄호 안에 선언되며, 메소드 호출 시 전달되는 값을 저장하는 변수는 (   )이다.   
매개변수
(2) 클래스 중괄호 내부에 선언되며, 객체가 생성될 때마다 생성되는 변수는 (   )이다.
인스턴스변수(필드, 멤버변수)
      참조변수      인스턴스변수
선언위치      메소드/블록내부   클래스 중괄호 내부
객체 생성시   객체를 가리키기만 함   객체안에 포함되어 생성됨   
객체마다 존재   참조만 바뀔수있음   존재함

(3) boolean, char, int 등은 모두 (   ) 자료형이다.
기본자료형(기본형, 기본)
(4) 하나의 자료형으로 여러 값을 저장할 수 있는 공간의 집합은 (   )이다.
배열(Array)
(5) final이 클래스에 붙으면 (           )이/가 불가능하고, final이 필드에 붙으면 (          )로 사용한다.
상속, 상수
 
문제 2. 다음 문장을 읽고 O 또는 X로 답하시오.
※ X인 경우, 그 이유를 간단히 서술하시오.
(1) static 메소드는 객체 생성 없이 클래스명으로 호출할 수 있다. ( O )
(2) 생성자가 하나도 없으면 컴파일러는 기본 생성자를 자동으로 생성하지 않는다. ( X )
   컴파일러가 기본 생성자를 자동 생성

(3) 상속받은 메소드를 자식 클래스에서 같은 이름으로 재정의하는 것을 오버로딩이라 한다. ( X )
   오버라이딩(오버로딩/오버라이딩 차이 작성)

(4) 객체지향 언어의 특징에는 다형성, 클래스, 상속, 캡슐화가 포함된다. ( O )
   
(5) 다음 코드에서 다운캐스팅은 반드시 필요하다. ( X )
ScoreCalculable score = students[i];
int avg = score.getAverageScore();
   
문제 3. 괄호 안에 들어갈 알맞은 용어를 작성하시오.
(1) 부모 타입의 참조변수로 자식 객체를 참조하는 것을 (   )이라고 한다.
   업캐스팅(Up casting)
(2) 부모 타입으로 참조된 객체를 다시 자식 타입으로 형변환하는 것을 (   )이라고 한다.
   다운캐스팅(Down casting)
(3) 객체의 실제 생성 타입을 확인할 때 사용하는 연산자는 (   )이다.
   instanceof
(4) instanceof 연산자는 객체의 (   )을/를 확인하고, == 연산자는 객체의 (   )을/를 비교한다.
   타입(클래스타입, 생성타입), 참조값(주소값, 같은 객체 여부)
(5) 인터페이스를 구현할 때 사용하는 키워드는 (   )이다.
   implements

문제 4. 다음 용어의 차이를 간단히 서술하시오.
※ 각 항목당 1~2문장 이내로 작성하시오.(키워드만 있으면 -1점 감점)

(1) 일반 클래스   
   객체 생성 가능, 모든 메소드 구현(인스턴스메소드, 스태틱메소드)   
(2) 추상 클래스
   객체 생성 불가, 추상메소드 1개 이상, abstract 키워드, 멤버(인스턴스변수, 스태틱변수, 상수, 일반메소드, 추상메소드)
(3) 인터페이스
   구현 강제, 다중구현 가능, 상속과 구현 동시 가능, 멤버(상수, 추상메소드)
 
문제 5. 접근제한자의 접근 가능 범위를 간단히 서술하시오.
※ 의미가 맞으면 정답으로 인정함.

(1) public   어디서나 접근가능(모든곳 허용)
(2) protected   같은 패키지 + 다른 패키지 상속 관계
(3) default   같은 패키지
(4) private   같은 클래스
-------------------------------------------------------------------------------------
zoom ID : 202 512 0414
비밀번호 : kdt251229!
-------------------------------------------------------------------------------------
복습 -> 인터페이스 -> 어댑터 -> 마커 인터페이스 -> 내부클래스 -> 익명클래스

0. 복습
1) 상속(Inheritance)
   기존 클래스(부모)를 재사용해서 새로운 클래스(자식)를 만드는 것
   공통 기능을 부모에 두고 자식은 확장/재정의

2) 캐스팅(Casting)
- 업 캐스팅(Up casting)
   자식 -> 부모 타입(자동 형변환)
   
   부모타입 참조변수 = 자식 참조값;
   
- 다운 캐스팅(Down casting)
   부모 -> 자식 타입(잘못된 Down Casting)
   업캐스팅 된 객체를 다시 자식 타입으로

- instanceof
   다운 캐스팅 전 필수적으로 사용 권장

3) 다형성(Polymorphism)
   하나의 타입으로 여러 객체를 다루는 것
   
- 오버로딩   : 같은 이름, 다른 매개변수(순서, 타입, 개수), 반환타입 영향없음
   메소드 오버로딩, 생성자 오버로딩
- 오버라이딩 : 선언부가 완전히 동일, 부모 메소드를 자식이 재정의
   상속관계, 자식 클래스에서 사용
   메소드 오버라이딩
- 참조변수의 다형성 : 캐스팅이 없으면 부모 기준으로만 사용
   
4) 추상클래스(Abstract Class)
- 추상 클래스
   추상 메소드를 하나 이상 가진 클래스
   객체 생성

- 추상 메소드
   선언부만 있고 구현부는 없음
   자식클래스에서 반드시 오버라이딩
   
- 추상 클래스를 사용하는 이유
   강제성 : 자식 클래스가 반드시 구현해야할 메소드를 지정
   
5) 인터페이스(Interface)
- 인터페이스
   완전 추상
   멤버 : 상수, 추상메소드
   객체 생성 x
   다중구현 가능

- 인터페이스의 특징
   모든 변수는 public static final
   모든 메소드는 public abstract

1. 인터페이스
1) 인터페이스를 사용하는 이유
   여러 클래스에서 선언할 멤버들을 일관되게 하기 위해 사용한다(표준화)
   관계 없는 클래스들을 그룹화 시킬 수 있다(마커 인터페이스)

+) 표준화(다형성 + 느슨한 결합의 기반)
   인터페이스는 구현이 아니라 규격(약속)을 정의한다
   이 타입이면 이 기능을 제공한다를 보장
   호출하는 쪽은 구현체가 뭔지 몰라도 인터페이스 타입으로 다룰 수 있음
   -> 결합도 ↓ 확장성 ↑ 테스트 용이성 ↑
   
+) 서로 관계 없는 클래스들의 타입 묶기
   관계없는 클래스라도 인터페이스를 구현하면 공통 타입으로 취급이 가능함
   (java 표준 라이브러리에 마커 인터페이스 많이 남아있음)
   
   초식동물   육식동물   잡식동물
   얼룩말   호랑이   사슴
   말   곰
      늑대
      독수리
      참새
      고양이
      강아지
      비둘기

2) 다중 상속
   여러 부모클래스를 상속하는 것을 다중상속이라고한다
   java는 모호성 때문에 다중 상속을 지원하지 않는다
   jdk 8버전(2014년)부터 인터페이스 default 메소드, static 메소드, private 메소드를 만드는 것을 허용하고 있다
   특정 메소드의 구현을 허용한다
   여러개를 구현(상속) 할 수 있는 인터페이스의 특징 때문에 다중 상속을 지원하는 것과 다름 없다

3) 인터페이스에 추가된 기능
- default 메소드를 선언할 수 있다
   default 리턴타입 메소드명(자료형 매개변수){
      //실행할코드;
      //return 리턴값;
   }

- static 메소드를 선언할 수 있다
   static 리턴타입 메소드명(자료형 매개변수){
      //실행할코드;
      //return 리턴값;
   }

- private 메소드를 선언할 수 있다(jdk 9버전부터 사용 가능)
   private 리턴타입 메소드명(자료형 매개변수){
      //실행할코드;
      //return 리턴값;
   }

4) 모호성(ambiguity)
   자바와 같은 언어에서 다중 상속과 관련된 경우에 발생할 수 있다
   다중 상속은 한 클래스가 여러개의 부모 클래스로부터 상속을 받는 것을 의미한다
   모호성은 자식 클래스에서 어떤 부모 클래스의 멤버를 호출해야하는지 명확하지 않을 때 발생한다

   => 하나의 자식이 여러 부모를 상속받을 때 서로 다른 부모 클래스에 동일한 이름의 멤버가 있다면
   어떤 부모의 멤버인지 알 수 없다

- 모호성 해결방법 예시
(1) 두 개의 인터페이스에 같은 메소드가(이름, 매개변수, 리턴타입이 같은 메소드) 선언되어 있는 경우
   -> 오버라이딩, 자식 클래스에서 재정의해서 사용한다
(2) 부모 클래스의 메소드와 인터페이스의 디폴트 메소드의 이름과 매개변수가 같다
   -> 부모 클래스의 메소드가 사용된다
      구현하는 인터페이스보다 상속받는 부모 클래스의 우선순위가 높기 때문이다

+) 인터페이스도 타입이다
   인터페이스는 부모이고 구현한 클래스가 자식이다

5) 인터페이스의 불편함
   인터페이스는 강제성이 강하기 때문에 구현하는 클래스에서 일부만 재정의하여 사용하는 것이 불가능하다
   이를 해결하기 위해서 Adapter라는 추상클래스를 활용한다

2. 어댑터 클래스(Adapter Class)
   인터페이스를 미리 구현한 추상 클래스
   모든 메소드를 비어있는 메소드(기본 구현)로 만들어 둔 클래스
   필요한 메소드만 오버라이딩해서 사용하면 되므로 개발자가 편하게 활용할 수 있다

1) 사용하는 경우
   인터페이스의 메소드가 많은 경우
   많은 메소드들 중에서 일부만 구현하고 싶은 경우

2) 어댑터클래스(추상클래스)와 인터페이스
   인터페이스의 강제성을 완화하기 위해 Adapter 클래스를 사용한다
   어댑터 클래스는 추상 클래스로 만들기 때문에 미구현된 메소드와 구현된 메소드가 동시에 존재할 수 있다
   그러므로 어댑터 클래스에서 인터페이스를 상속받아 강제성을 없애고 싶은 메소드만 재정의 해준다
   이 후 어댑터 클래스를 상속받는 자식 클래스는 내가 원하는 메소드만 재정의 할 수 있게 된다
   이 때 어댑터 클래스의 이름은 클래스명 + Adapter를 붙여서 목적을 알려준다

   인터페이스(모든 강제성) --- (일부구현)---> 추상클래스(일부 강제성)---(상속)---> 클래스

2. 마커인터페이스
   아무런 멤버도 포함하지 않으며 클래스에 대한 메타 정보를 제공하는 용도로 사용된다
   주로 다른 클래스나 인터페이스에 특정 속성이나 특징을 부여하기 위해 사용된다
   클래스들을 그룹화 하기 위한 목적으로 사용하며 서로 다른 클래스들을 공통되는 타입을 갖도록 하는 것이 목적이다
      
//      Serializable 직렬화
//      Cloneable
//      RandomAccess