day05(java 3일차)

박지수 : 1시간 지각 
김유광 : 30분 지각
윤철민 : 30분 지각
변재원 : 목요일까지 결석
정현주 : 오전 센터 방문

-----------------------------------------------------------------------------
260106 한컴타자연습
한타 : 수학개념
영타 : K-Food

복습 -> review -> 형변환 -> 입력메소드 -> 연산자1

0. 복습
1) 프로그램 개발 순서
[일반프로그램 기준]
	소스파일 작성 -> 컴파일 -> 실행(CPU는 이 기계어 명령어를 해석하고 실행함)

[Java 프로그램 기준]
	Hello.java -- javac(자바 컴파일러) --> Hello.class(바이트코드) -- java(JVM이 실행)-->실행결과출력

2) JDK, JRE, JVM
- JVM 
	Java 프로그램이 실행되는 환경
	자바 바이트코드(.class)를 실행해주는 가상 머신
	운영체제마다 다른 JVM이 존재함

	- 클래스 로딩
	- 바이트 코드 해석 및 실행
	- 메모리 관리(Garbage Collection 포함)

- JRE
	JVM + Java 프로그램 실행에 필요한 라이브러리/파일 묶음
	자바로 만들어진 프로그램을 실행하려면 JRE가 필요함

	- JVM
	- rt.jar(런타임 클래스들)
	- 다양한 표준 클래스 라이브러리

- JDK
	자바 프로그램을 개발하기 위한 도구 모음
	개발자용 패키지 -> 컴파일, 디버그, 실행 가능

	- JRE 포함
	- 컴파일러(javac)
	- 디버거(jdb)
	- 다양한 개발도구(jar, javadoc 등)
	
구성요소	포함관계	용도
JVM	-	Java 프로그램 실행
JRE	JVM	실행환경(라이브러리 + JVM)
JDK	JRE	개발도구 포함(컴파일, 디버깅 등)

3) 변수(Variable)
	하나의 자료형과 하나의 값이 저장되는 저장공간
	값을 재사용하기 위해서 사용한다
	
- 변수 선언
	자료형 변수명;

- 변수 초기화
	변수명 = 값;

- 선언과 동시에 초기화
	자료형 변수명 = 값;

+) 주소값
	메모리(RAM : Random Access Memory)에 저장공간이 할당되면 고유한 값인 주소값이 부여된다
	값은 변경될 수 있으나 중복은 없다

4) 자료형(Data Type)
	자료형	타입	크기		범위
	정수형	byte	1byte(8bit)	-128 ~ 127
		short	2byte(16bit)	-32,768 ~ 32,767
		int	4byte(32bit)	-2,147,483,648 ~ 2,147,483,647
		long	8byte(64bit)	-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807		정수L
	실수형	double	8byte(64bit)	소수점이하 약 15자리 정밀도
		float	4byte(32bit)	소수점이하 약 6자리 정밀도
	논리형	boolean	1byte(8bit)	true, false
	문자형	char	2byte(16bit)	유니코드 문자 하나 저장(0 ~ 65535)
	문자열 	String	??		""감싸진 0개 이상의 문자열

5) 상수(constant)
	변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미
	프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다
	
- 상수 선언 
	final  자료형 상수명 = 값;
	* 상수명 : 대문자로 작성, _연결(스네이크 케이스)

+) 리터럴(literal)
	그 자체로 값을 의미
	변수, 상수와 달리 데이터가 저장된 메모리 공간을 가리키는 이름을 가지고 있지 않는다

6) 제어문자
	따옴표 안에서 작성, \를 사용해서 작성
	\n \t \' \" \\

7) 출력메소드
	println()
	print()
	printf()	=> %d 정수, %f 실수(소수점 6자리까지), %b 논리, %c 문자, %s 문자열
			%[- or 0][n][.m]서식문자

1. 형변환(Type Casting)
1) 강제형변환	
	(자료형) 값
2) 자동형변환
	작은 byte 값을 큰 byte의 변수에 저장할 때
	정수 + 정수 => 정수, 정수 + 실수 => 실수
	문자는 정수로 자동 형변환(유니코드)

+) 자료형
	int
	long
	double
	float
	boolean
	char
	String	=> 클래스 타입, 레퍼런스 타입

3) 다른 기본 자료형 -> 문자열 형 변환
	+ ""	연결

4) 문자열 자료형 -> 다른 기본 자료형 형 변환
	String(클래스자료형, 참조자료형, Reference Type)
	int, long, double, float, boolean, char(기본자료형, 원시타입, Primitive Type)

	모든 기본 자료형을 담고있는 클래스 타입이 있고 String을 다른 자료형으로 변환시에 이 클래스 타입의 도움을 받는다

	int => Integer.parseInt()
	long => Long.parseLong()
	double => Double.parseDouble()
	float => Float.parseFloat()
	boolean => Boolean.parseBoolean()
	char => "문자열".charAt(int index)
		charAt 메소드의 소괄호 안에는 정수형으로 0부터 시작하는 방번호를 1개만 작성할 수 있다
		★ 인덱스라고 부르며 0부터 시작한다

2. 입력 메소드
1) 함수
	기능
	이름뒤에 소괄호

2) 메소드
	함수와 동일
	java에서 모든 함수는 클래스 내부에 만들어지므로 메소드라고 말한다

	System.out.println()

3) 입력클래스(Scanner 클래스)
	입력 메소드를 사용하기 위해서는 반드시 입력 클래스를 불러와야한다
	입력 클래스가 위치한 패키지가 다르기 때문에 패키지 안에 있는 클래스를 불러와야한다
	package와 class 사이에 import java.util.Scanner; 한줄이 추가되어야 제대로 사용가능해진다

	자료형 변수명 = 값;
	String str1 = "hello";
	Scanner sc = new Scanner(System.in);

	자동 import 단축키 : ctrl + shift + o

4) 입력메소드
	Scanner 클래스 내부에 입력 메소드가 만들어져있다
	next() : 입력받은 값을 String 타입으로 돌려준다
		(입력받은 값을 변수에 저장할 경우 String타입의 변수를 만들어야한다)
		입력한 값을 띄어쓰기와 엔터로 구분하고 분리한다
		임시저장공간(buffer)에서 엔터를 소모하지 않는다
		- 성 이름 으로 입력시 첫번째 문자열을 첫번째 next()에 담고 두번째 문자열은 두번째 next()에 담는다
		- 띄어쓰기와 엔터는 계속 임시 저장공간에 남아있다
		김 영선
		String name1 = sc.next();
		String name2 = sc.next();
		syso(name1); //김
		syso(name2); //영선
	
	nextLine() : 입력받은 값을 String타입으로 돌려준다
		띄어쓰기를 포함한 한 줄 전체를 입력받는다
		엔터 이전까지의 값을 가져온다
		엔터를 임시 저장공간에서 소모한다(지워준다)
		
		김 영선
		String name1 = sc.nextLine();
		String name2 = sc.nextLine();
		syso(name1); //김 영선
		syso(name2); //짱구

		김 영선
		String name1 = sc.next();
		String name2 = sc.nextLine();
		syso(name1); //김
		syso(name2); // 영선

	nextInt() : 입력받은 값을 정수 (int)타입으로 돌려준다
		입력한 값을 띄어쓰기, 엔터로 구분하고 분리한다
	nextDouble() : 입력받은 값을 실수 (double)타입으로 돌려준다

	=> next(), nextInt(), nextDouble()을 사용하면 엔터값이 남아있게 되는데 다음에 nextLine()을 사용하게되면
	남아있던 엔터가 들어가서 입력을 받지 않게 된다
	따라서 입력 받기 전에 nextLine()을 사용하여 엔터를 소모시켜야한다


+) 자료형의 기본값
	정수	byte	0
		short	0
		int	0
		long	0L	
	실수	double	0.0
		float	0.0F
	문자형	char	'\u0000' 널문자
	논리형	boolean	false
	문자열	String	null

	자료형 변수명;
	변수명 = sc.next();

3. 연산자1
	기능이 있는 특수 문자

1) 연산자의 우선순위
	최우선 연산자
	단항
	산술	
	쉬프트
	관계	
	논리
	삼항
	대입

2) 결합성
	하나의 수식에 동일한 연산자가 여러개 사용되면 알맞은 방향으로 결합되어 연산되는 성질
	
4. 산술연산자
	+	int, long, double, float	연산
		String	 			연결
	-	int, long, double, float	연산
		String 사용불가
	*	int, long, double, float	연산
		String 사용불가
	/	int, long, double, float	연산
		String 사용불가
		int / int -> int(몫)
		0으로 나눌 수 없다
	%	나머지 연산자

5. 복합대입연산자, 누적연산자
	+=	더해서 대입
	-=	빼서 대입
	*=	곱해서 대입
	/=	나눠서 대입
	%=	나머지 대입
	
6. 증감연산자
	++	1증가
	--	1감소

	전위형 : 해당 라인부터 바로 적용
		int num = 5;
		--num;	//4

	후위형 : 다음 라인부터 적용(정확히는 증감 연산자가 끝난 시점부터 적용)
		num++; //4
		num;   //5

	++x	먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함
	x++	먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴
	--x	먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함
	x--	먼저 해당 연산을 수행하고 나서 피연산자의 값을 1 감소시킴

	int num1 = 7, num2 = 7;
	int result1, result2;

	result1 = --num1 + 4;
		    6 + 4 => 10
		1) --num1 먼저 감소	num1의 값 : 7 -> 6
		2) 연산 수행		6 + 4 = 10
	result2 = num2-- + 4;
		    7 + 4; => 11
		num2 => 6
		1) num2--	num2값을 먼저 사용 7
		2) 연산 수행 	7 + 4 = 11
		3) 연산 수행 후 감소 	num2의 값 : 7 -> 6

★ 무조건 암기
	전위(++x, --x) : 먼저 증가/감소 -> 연산
	후위(x++, x--) : 먼저 연산 -> 나중에 증가/감소

7. 관계연산자
	조건식
	관계연산자의 결과는 참, 거짓 둘 중 하나가 나오는 식(boolean 타입으로 결과가 나온다)
	
	a > b : a가 b보다 크니? 맞으면 true, 틀리면 false
	a < b : a가 b보다 작니? 맞으면 true, 틀리면 false
	a >= b : a가 b보다 크거나 같니? 맞으면 true, 틀리면 false
	a <= b : a가 b보다 작거나 같니? 맞으면 true, 틀리면 false
	a == b : a가 b랑 같니? 맞으면 true, 틀리면 false
	a != b : a가 b랑 같지 않니? 맞으면 true, 틀리면 false
















