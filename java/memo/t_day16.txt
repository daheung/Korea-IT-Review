day16(java 14일차)
복습 -> 람다식 -> 예외처리 -> Object 클래스

0. 복습
1) 상속 : 부모클래스의 기능을 재사용 + 확장
   extends
   단일 상속만 가능

2) 캐스팅(Casting)
   업캐스팅   : 자식 참조값을 부모 타입으로
      다형성의 핵심
      부모기준으로만 접근 가능(오버라이딩 된 메소드는 재정의 된 내용)
   다운캐스팅 : 업캐스팅된 객체만 가능
      instanceof 체크
      
3) 다형성(Polymorphism)
   하나의 타입으로 여러 객체를 다룬다

   오버로딩   : 같은이름, 매개변수 타입/순서/개수 다름, 반환타입 무관
   오버라이딩 : 상속관계 필수, 부모클래스의 선언부와 자식클래스의 선언부가 완전 동일
      실행 시점에 결정(동적바인딩) 
   참조변수 다형성 : 부모 타입 -> 부모 멤버만 사용 가능
      
4) 추상클래스(Abstract Class)
   추상클래스 : 추상메소드가 1개 이상, 객체 생성 불가, 상속을 통해 사용
   추상메소드 : 구현부 없음, 자식 클래스에서 반드시 오버라이딩
      
   public abstract class AClass{
      abstract void method();
   }

5) 인터페이스(Interface)
   상수, 추상메소드
   + default 메소드, static 메소드, private 메소드 => 구현된 메소드로 정의 가능

   객체 생성 불가
   다중 구현 가능
   
   변수 : public static final
   메소드 : public abstract

- 인터페이스를 사용하는 이유
   강제성
   표준화
   관계없는 클래스 묶기(마커인터페이스)

- 모호성(Ambiguity)
   인터페이스 - 인터페이스
   동일한 default 메소드 -> 반드시 오버라이딩

   클래스 - 인터페이스
   일반메소드 - 동일한 default 메소드 -> 클래스 메소드 우선

- 인터페이스 단점
   강제성이 너무 강함
   메소드가 많으면 불편

6) 어댑터 클래스(Adapter Class)
   인터페이스를 미리 구현한 추상 클래스
   모든 메소드를 빈 구현

   필요한 메소드만 오버라이딩 가능 장점

   인터페이스 -> 어댑터클래스(추상클래스) -> tlfwp zmffotm

7) 마커 인터페이스(Marker Interface)
   멤버 없음
   메타 정보 제공
   타입 체크 용도

8) 내부 클래스(Inner Class)
   클래스 내부에 선언된 클래스
   외부 클래스 객체 있어야 생성 가능(일반적으로)

- 장점
   외부 클래스 멤버 접근 쉬움
   캡슐화 ↑
   코드 구조화

- 내부 클래스의 종류
   인스턴스 내부 클래스      외부 객체 필요      패키지명.외부클래스명$내부클래스명@
   static 내부 클래스      외부 객체 없이 생성
   로컬 내부 클래스      메소드 실행시만
   
9) 익명클래스
   이름이 없는 클래스
   일회성 구현
   객체 생성과 동시에 구현
   
   사용 목적   : 추상클래스/인터페이스 즉시 구현
        코드 간결
        람다 이전에 핵심 문법

1. 람다식(lambda)
1) 식과 문의 차이
   - 식(Expression) : 평가하면 값이 된다
   - 문(Statement) : 실행되는 명령이다
   
   - 모든 식은 대부분 문으로 쓸 수 있다
   - 하지만 모든 문은 식이 아니다

(1) 식
   평가하면 값이 나오는 코드 조각
   값이 항상 타입을 가진다   

   1 + 2   //3
   "Hello" //Hello
   x   //x에 저장된 값
   x > 10   // true or false
   method() //리턴값이 있다면 그 값
   new Person()   //생성된 객체(참조값)

(2) 문
   실행 가능한 최소 단위의 명령(컨트롤 플로우 포함)
   실행은 되지만 평가해서 값이 나오지 않기 때문에 변수에 저장 x, 메소드 매개변수로 전달 x

   제어문
   - 조건문
   - 반복문
   
   if(x > 0) { ... }
   for(int i = 0; i < 5; i++) { .. }
   while(true) { ... }
   break;
   cotinue;

(3) 문은 식을 포함할 수 있다

(4) 식은 값으로 평가된다
   어떤 식은 값이 생기더라도 그 값을 어디에도 안쓰고 버릴 수 있음
   -> 식 문(expression statement)
   대입, 증감, 메소드 호출, 객체 생성(거의 안쓰지만 문법상 가능)

   x++;
   method();   // 리턴값이 있어도 그냥 버리면 문으로 사용
   a = b + 1;   // 대입식 자체도 값이 있음(대입된 값)

(5) 문은 값이 아니라서 변수에 저장 불가능
   
2) 함수형 인터페이스(Functional Interface)
   단 하나의 추상메소드를 가지고 있는 인터페이스
   @FunctionalInterface 어노테이션을 명시하면 하나의 추상 메소드만 선언할 수 있도록 제한 할 수 있다

- 문법
   @FunctionalInterface
   interface MyFunc{
      //상수, 추상메소드, default 메소드, static 메소드, private 메소드
      
   }

- @FunctionalInterface
   이 인터페이스는 함수형 인터페이스여야한다는 것을 컴파일러에게 알려주는 검증용 어노테이션

- 사용하는 이유 ★★★
   (1) 컴파일 타임 오류 방지
      실수로 추상메소드를 2개 이상을 만들면 즉시 컴파일 에러
      
   (2) 의도 표현(가독성)
      람다용으로 쓰라고 만든거야

   (3) 람다식을 사용하기 위함
      람다식을 사용 시 에러발생을 막기위해 어노테이션으로 명시하여 알려준다

+) 람다식을 이용한 객체 생성시 객체 출력 결과
   LambdaTest02.Print$$Lambda/0x0000028b81001a18@77459877

   람다식 객체의 toString() 결과
   익명 클래스처럼 보이지만 실제로는 JVM이 내부적으로 만든 특수한 클래스의 객체

   - LambdaTest02.Print   람다식이 작성된 패키지와 클래스
            람다를 포함하고 있는 외부 클래스
   - $$Lambda      JVM이 자동 생성한 람다 전용 내부 클래스
            컴파일 시점이 아닌 런타임에 생성
            
   - /0x0000028b81001a18   JVM 내부에서 사용하는 클래스/메타데이터 식별 주소
            내부 식별자
            실행할 때마다 달라짐
   - @77459877      객체의 hashCode(16진수 아님, 10진수)
            Object.toString() 기본형식 => 클래스이름@해시코드


+) 익명클래스와 람다 차이
      익명클래스      람다
클래스 생성   컴파일 시 .class   런타임 생성(invokedynamic)   
클래스 이름   외부$번호      $$Lambda
객체 성격      일반 클래스   JVM 최적화 대상
재사용      매번 새 클래스   재사용 가능


3) 람다식 : 익명 메소드
   jdk 8 이상부터 사용가능하다
   메소드를 하나의 식으로 표현한다
   람다식을 매개변수로 전달 가능하며, 반환도 가능하다
   함수형 인터페이스는 추상메소드가 1개만 선언되기 때문에 람다식으로 재정의할 때 메소드의 이름이 필요 없다

4) 람다식 문법
   매개변수 -> 바디
   day16프로젝트 > lambdaTest01 패키지 LambdaTest.java 참고(람다식 만드는 방법)

+) 람다식 활용
   스트림API 활용
   이벤트 핸들러
   쓰레드와 비동기 처리
   커스텀 함수 인터페이스