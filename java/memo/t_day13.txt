day13(java 11일차)

* 지각자 : 없음

260116 금
한타 : 한국창작동요1
영타 : Louis Napoleon
-------------------------------------------------------------
복습 -> 상속 -> super, super() -> 오버라이딩 -> 접근 제한자

0. 복습
1) 클래스(Class)
	사용자 정의 자료형
	필드 + 메소드 + 생성자를 하나로 묶은 설계도

- 객체화(인스턴스화)
	클래스타입 참조변수 = new 생성자();

2) 생성자(Constructor)
	객체 생성 시 자동 실행
	필드 초기화 목적
	리턴타입 x

- 기본생성자
	public 클래스명(){}

- 매개변수 생성자
	public 클래스명(자료형 매개변수){
		this.필드 = 매개변수;
	}

3) this, this()
	this : 객체 자기 자신(참조값)
		필드와 매개변수 구분
	this() : 자기자신의 생성자
		같은 클래스의 다른 생성자 호출
		생성자 내부 최상단에만 작성 가능

4) 변수의 종류
			선언위치		특징
	지역변수		메소드/생성자 내부	호출 시 생성
	매개변수		메소드 선언부 소괄호	호출 시 생성
	인스턴스변수	클래스 내부		객체마다 다름
	정적변수		static		객체 간 공유

5) static (정적멤버)
	프로그램 시작 시 생성
	프로그램 종료까지 유지
	객체 생성 없이 사용 가능

- static 변수
	모든 객체가 하나의 값을 공유
	ex) static int count;

- static 메소드
	객체 없이 호출 가능
	인스턴스 멤버 직접 사용 불가
	ex) 클래스명.메소드명();

6) JVM 메모리구조
	영역	저장내용			관리
	Method	클래스정보, static		JVM
	Heap	객체, 인스턴스변수		GC
	Stack	지역변수, 호출 정보		JVM

7) enum (열거형)
	고정된 상수 집합을 하나의 타입으로 정의
	값의 범위를 제한 -> 오류 방지

- enum 사용이유
	타입 안정성
	가독성 향상
	컴파일 타임 오류 방지
	관련 기능 묶기 가능

+) enum
	클래스
	상수 하나 = 객체 하나
	상수는 JVM이 미리 생성한 고정 객체
	public static final 자동 포함
	필드, 생성자, 메소드 정의 가능함
	생성자의 접근 제한자는 private


+) enum에서 추상화가 사용되는 경우
	상수마다 동작이 다를 때 (if/switch로 분기가 필요할 때)
	enum 내부 추상메소드
	
+) enum에서 추상화가 필요없는 경우
	모든 enum 값이 동일한 로직
	값 차이는 데이터(필드)로만 표현 가능
	조건 분기 1~2개정도이고 더 확장되지 않을 때
	
1. 상속(inheritance)
	기존 클래스의 멤버를 재사용하고 필요한 기능만 추가하여 새로운 클래스를 만드는 방식
	
1) 상속 문법
	class Parents{
		//필드, 생성자, 메소드
		//Parents 클래스의 멤버
	}

	class Child extends Parents{
		//필드, 생성자, 메소드
		//Child 클래스의 멤버
		//Parents 클래스의 멤버
	}
	
2. super, super()
	this	객체 자기자신(참조값)
	this()	자기자신의 생성자
	super 	부모의 참조값
		부모의 멤버에 접근할 때 사용된다
	super()	부모 생성자
		자식클래스 타입의 객체로 부모 필드에 접근할 수 있다
		객체를 만들 때 자식 생성자만 호출하기 때문에 자식 필드만 메모리에 할당된다고 생각할 수 있다
		ex) Child c = new Child();
		자식 생성자는 항상 부모 생성자를 호출한다
		이는 자식의 필드를 초기화 할 때 부모 필드도 초기화하는 것을 의미한다
		즉, 자식 객체를 생성하게 되면 부모 객체도 같이 생성하게 된다(부모객체가 먼저 생성된다)	
		부모 생성자를 호출하는 방법은 super()를 사용하면 된다
		만약, super()를 작성하지 않더라도 컴파일러가 자동으로 작성해준다

- this(), super()는 같은 생성자에서 함께 사용 불가
- 상속 구조에서는 부모 생성자 호출 -> 자식 생성자 호출 순서로 확인한다

+) this, this(), super, super()
this	현재 객체 참조(참조값)
	지역변수와 멤버 변수의 이름이 겹칠 때 구분하기 위해 사용, 현재 객체 자신을 가리킬 때 사용

this()	같은 클래스의 다른 생성자 호출
	생성자 코드 중복을 줄이기 위해 사용
	반드시 생성자 첫 줄에 위치

super	부모 클래스 참조
	부모 클래스의 필드/메소드에 접근할 때 사용
	오버라이딩 된 메소드를 부모 메소드로 호출 할 때 사용

super()	자식 클래스 생성 시 부모 생성자 먼저 호출되며 필요할 때 사용
	생략시 기본적으로 super()가 자동으로 삽입됨
	반드시 생성자 첫 줄에 위치

3. 오버라이딩
	다형성 : 하나의 것으로 여러 형태를 가진다
	- 오버로딩 : 생성자, 메소드 오버로딩
		같은 클래스 내에서 매개변수의 순서, 타입, 개수가 다르면 같은 이름으로 정의할 수 있다
		반환타입은 영향을 주지 않는다

1) 오버라이딩(재정의)
	상속관계, 메소드 오버라이딩
	부모 클래스에 정의한 메소드를 자식 클래스에서 수정해서 사용하고 싶다면 오버라이딩을 하면 된다
	이 때 메소드의 선언부(리턴타입 메소드명(자료형 매개변수))의 내용이 동일해야한다
	구현부의 내용만 재정의해서 사용한다
	
------------------------------------------------------------------------------------------
gameTask
Character 클래스
	슈퍼클래스 기반으로 서브 클래스 생성 후 아래 요구사항을 확인하여 코드 완성하기

기본 공격 	
	00이 기본 공격을 사용했습니다. 피해량 : x 출력
	mp는 감소하지 않음
스킬 공격
	mp가 10이상이면 mp 감소후 공격
	mp가 부족하면 마나가 부족합니다 출력
특수 공격
	Character에서는 아무 동작도 하지 않음
CheckMp
	mp가 필요한 mp 이상이면 true 반환
	아니면 마나가 부족합니다 출력후 false 반환
revive
	hp가 0이하가 되면 자동부활
	hp, mp를 최대값으로 회복

서브클래스
1) Wizard 클래스
	기본 생성자를 통해 마법사, 15, 30, 1, 30, 0 전달
	normalAttack()	오버라이딩 : 체력 2감소 후 공격 실행
	skillAttack()	오버라이딩 : mp가 부족하면 출력 후 스킬 사용 실패
	specialAttack()	오버라이딩 : 마법사는 특수공격이 없습니다 출력

2) Warrior 클래스
	기본 생성자를 통해 전사, 30, 10, 5, 15, 100 전달
	skillAttack() 	오버라이딩 : mp가 3보다 부족하면 실패, 아니면 mp 3소모
	specialAttack()	오버라이딩 : 피해 출력 + 체력 10 감소 + 부활 검사
	onlyWarrior()	오버라이딩 : 전사만 사용할 수 있는 고유 행동입니다 출력

3) Rogue 클래스
	기본 생성자를 통해 로그, 20, 20, 3, 20, 0 전달
	normalAttack()	오버라이딩 : mp3 소모, 부족하면 실패
	skillAttack()	오버라이딩 : mp2 소모 + hp 5소모, 부족하면 실패
	specialAttack()	오버라이딩 : 20 ~ 100사이의 무작위 피해량 출력(Random 클래스 사용)
	정수형 배열 필드 이용

4) Main 클래스 => main method
	사용자에게 캐릭터를 선택하게 하고 1. 마법사, 2. 전사, 3. 로그
	선택한 캐릭터로 반복적으로 메뉴 실행
	1. 기본공격, 2. 스킬공격, 3. 특수공격, 4. 종료
	그외 번호 입력시 잘못 입력했습니다 출력 후 다시 입력받기

------------------------------------------------------------------------------------------
=> 오버라이딩(Overriding)
	상속관계에서 부모 클래스의 메소드를 자식 클래스에서 동일한 선언부로 다시 정의해서
	자식에게 맞게 동작을 바꾸는 것

@Override 어노테이션
	오버라이딩 검사기
	선언부가 틀리면 컴파일 에러 발생
	실수 방지용

* final이 붙은 메소드는 오버라이딩 불가

4. 접근 제한자(접근권한 제어자, 접근자) 	Access Modifier
	클래스, 필드, 생성자, 메소드에 붙여서 누가 접근할 수 있는지를 제한하는 키워드
	
1) 접근 제한자의 목적
	캡슐화(Encapsulation) 실현
	외부에서 직접 접근하면 안 되는 것을 보호
	클래스 사용 방법을 명확하게 제한

2) 접근 제한자 종류
	키워드		접근제한자
	public		전체 공개
	protected	상속 + 같은 패키지
	(default)	패키지 전용
	private		클래스 내부 전용

3) 사용 가능한 대상
	제한자		클래스		필드	생성자	메소드
	public		O		O	O	O
	protected	x(중첩클래스만 가능)	O	O	O
	(default)	O		O	O	O
	private		x(중첩클래스만 가능)	O	O	O

	※ 최상위 클래스(top-level class)
	=> public 또는 (default)만 가능

4) 접근 허용 범위
	제한자		같은클래스	같은패키지	다른패키지(상속x)	다른패키지(상속o)
	public		O	O	O		O
	protected	O	O	X		O
	(default)	O	O	X		X
	private		O	X	X		X


+) protected 생성자는 다른 패키지에서 new로 못쓰게 한 이유
- 생성자의 본질
	생성자는 단순한 메소드가 아닌 객체 생성 경로를 통제하는 장치
	(누가, 어떤 방식으로, 어떤 타입의 객체를 생성할 수 있는지를 제한하기 위함)

- protected의 의미
	메소드의 protected : 상속받은 클래스 내부에서 사용 가능
	생성자의 protected : 상속을 통해서만 객체 생성 가능
	=> 이 클래스를 직접 쓰지말고 상속해서 써라

만약 protected 생성자를 new로 허용했다면 생기는 문제
	//다른 패키지
	Constructor c = new Constructor(10);
	상속 없이도 객체 생성 가능
	protected 의미 붕괴
	public 생성자와 사실상 차이 없음
	
- java 설계자의 의도
	protected 생성자의 진짜 목적
	=> 객체 생성은 허용하되, 반드시 자식 클래스의 일부로만 생성되게 하자
	(상속 구조 안에서만 생성)

- 왜 super()만 허용했는가?
	부모 객체는 자식 객체의 일부
	부모 생성은 자식 생성과정에 종속
	객체 생성 흐름
		Child 객체 생성
		-> Parent 생성자 호출
		-> Child 완성
		부모 객체 단독 생성 불가함!!!

- 설계 관점에서 본 장점
1) 상속 구조 보호
	부모 클래스를 단독 인스턴스화 금지
	반드시 자식으로 확장해서 사용
2) 추상 클래스 대체 효과
	abstract클래스가 아니어도 직접 생성 금지 구현 가능
3) 프레임워크 설계에 유리
	protected Framework(){}
	라이브러리 사용자는 직접 생성하지 않고 상속해서 확장해 사용한다
	=> Spring, JPA, Android에서 자주 사용됨

5. private 접근제한자
	같은 클래스 내부에서만 접근 가능한 접근 제한자
	완전한 정보 은닉(Encapsultion)을 위한 도구

1) 특징
	접근범위	같은 클래스 내부
	상속	상속되지 않음
	오버라이딩	불가능
	사용목적	내부 구현 숨김
	캡슐화	최강

2) 필드에 private 사용
	캡슐화와 관련
	필드는 무조건 private 접근 제한자를 붙인다(실무 기본 규칙)

3) 메소드에 private 사용
	내부 로직 분리
	외부 호출 차단
	변경 영향 최소화

4) 생성자에 private 사용
	객체 생성 통제
	Singleton / Factory 패턴
	Utility 클래스

---------------------------------------------------------------------------------
능단평1 시험범위
변수 ~ 접근제한자까지 + 월요일 진행내용까지

1/20/ 능단평1 
시험시간 9시 10분 ~ 10시 40분

각 문제 안에 소문제 존재함
단답형 3문제
서술형 2문제
코드구현 3문제
------------------------------------------------
팀스터디2	
스터디 1팀 => 이창표
스터디 2팀 => 정현주
스터디 3팀 => 서정원
스터디 4팀 => 오명근

자격증 시험 체크































