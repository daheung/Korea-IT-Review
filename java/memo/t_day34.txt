day34(java 20일차)
java 전체 복습 -> 쓰레드

java 전체복습
1. 저급언어와 고급언어
   저급언어(Low-level)      고급언어(High-level)
정의   컴퓨터가 이해하는 0과 1로 표현   사람이 이해할 수 있는 언어
종류   기계어(0, 1), 어셈블리어      java, c++, python 등
이식성   낮음(os에 따라 달라짐)      높음(os에 영향을 받지 않음)
실행속도   매우 빠름            상대적으로 느림
번역   하드웨어 직접 실행하므로 불필요   컴파일러/인터프리터로 번역 후 실행

2. 자바 프로그래밍 언어
   프로그래밍 언어 : 컴퓨터와 개발자가 소통하기 위한 언어

1) 동작원리
   [일반프로그램]      [java 프로그램]
   프로그램         프로그램
   ↓         ↓
   운영체제(OS)      JVM(자바 가상머신)
   ↓         ↓
   하드웨어         운영체제
            ↓
            하드웨어

2) JAVA 철학
   Write Once, Run Anywhere
   java코드 -> 컴파일러 -> 바이트코드(.class) -> JVM이 각 OS에 맞게 실행

   제임스 고슬링(James Gosling)
   1991년 Sun Microsystems에서 Oak 이름으로 개발 시작
   -> 1995년 java로 이름을 바꿔 공식 발표

3) jvm, jre, jdk
- JVM
   운영체제에 맞춰서 JAVA로 만든 프로그램을 실행시킨다
   JVM이 운영체제가 Bytecode를 이해할 수 있도록 도와줌

- JRE
   JVM을 실행한다
   JVM을 실행할 때 필요한 라이브러리 파일등을 가지고 있다

- JDK
   JRE를 포함한다
   JRE외에 개발에 필요한 도구들을 가지고 있다

3. 변수
   하나의 값을 저장하는 저장공간
   값을 재사용하기 위해 사용함

- 변수명 규칙
   카멜표기법, 명사, 의미있는 단어 사용

- 선언
   자료형 변수명 = 값;

4. 자료형
   정수   byte, short, int, long
   실수   double, float
   논리   boolean
   문자형   char
   문자열   String

- 기본자료형끼리의 형변환
   자동 형변환      큰 저장공간에 작은 값이 들어갈 때   byte -> short -> int -> long -> float -> double
         정수 + 정수 = 정수, 정수 + 실수 = 실수
         문자형 정수형 변환
         char al = 65;   'A'
         int result = 'a'; 97
   강제 형변환      큰 타입의 값이 작은 타입의 저장공간에 들어갈 때(데이터 손실 가능성이 있어 직접 명시해야함)
         
5. 연산자 우선순위
   최
   단
   산
   쉬
   관
   리
   삼
   대

6. 제어문
   조건문   if문, switch문
   반복문   for문, while문, do~while문
   기타제어문   break, continue, return

7. 배열
   하나의 타입으로 여러 값을 저장할 수 있는 저장공간
   저장공간의 나열
   - 저장공간 여러개를 이름 하나로 관리할 수 있음
   - 규칙성이 없는 값에 규칙성 부여할 수 있음(인덱스)
   - 하나의 타입으로 된 여러 값을 저장할 수 있음

   
1) 배열 생성
   어떤 값을 넣을 지 알 때
   자료형[] 배열명 = {값1, 값2, 값3};
   자료형[][] 배열명 = {{1, 2, 6}, {3, 4, 5}};
   
   몇칸이 필요할 지 알 때
   자료형[] 배열명 = new 자료형[크기];
   자료형[][] 배열명 = new자료형[행][열];

   어떤 값을 넣을지도 모르고 몇칸이 필요한지도 모를 때
   자료형[] 배열명 = null;
   자료형[][] 배열명 = null;

2) 배열의 길이
   1차원 : 배열명.length;
   2차원 행 : 배열명.lenght;
   2차원 열 : 배열명[행].length;

8. 메소드
   기능
   - 소스코드의 간결화
   - 코드의 재사용
   - 모듈화(모듈=부품)

1) 메소드 정의
   리턴타입 메소드명(자료형 매개변수){
      실행할 코드
      return 리턴값;
   }

2) 메소드 호출
   매개변수   리턴타입      호출방식
   x   x      객체명.메소드명();
   o   x      객체명.메소드명(인수);
   x   o      syso(객체명.메소드명());
   o   o      syso(객체명.메소드명(인수));

3) 매개변수
- 디폴트 매개변수 : 불가능 (오버로딩으로 활용-기본값 설정)
- 가변 매개변수 : 매개변수의 개수가 몇개인지 모를 때 사용 내부적으로 배열로 처리됨
      맨 마지막에 위치해야한다!
   자료형... 매개변수명
   리턴타입 메소드명(String name, 자료형... 매개변수){
      //매개변수.length;   
   }

4) 메소드 오버로딩/생성자 오버로딩
   같은 메소드명으로 매개변수의 순서, 개수, 타입이 다를 때 선언할 수 있다
   리턴타입은 영향을 주지 않는다

9. 클래스
   사용자 정의 타입
   연관성 있는 여러개의 타입과 여러개의 기능을 한 곳에 모아 편리하게 관리할 수 있다
   객체를 생성하기 위한 틀, 설계도

1) 클래스 선언
   class 클래스명{
      //필드
      //메소드
      //생성자
   }

2) 객체 생성(객체화, 인스턴스화)
   객체를 만드는 작업
   
   클래스명 참조변수 = new 생성자();
   클래스명 : 구체화 시킬 클래스의 이름을 기재한다
   참조변수 : 객체의 주소값을 담는다
   new : heap 메모리에 할당시킨다
   생성자 : 필드를 초기화

3) 생성자
   클래스명 뒤에 소괄호가 있는 형태
   필드를 초기화해준다
   직접 선언하지 않으면 컴파일러가 기본 생성자를 자동으로 만들어준다

4) this, this()
   this : 객체 자기자신
      객체의 주소값을 this라는 변수에 담을 수 있으며, 자동으로 담기게 된다
      일반적으로 생성자의 매개변수와 클래스의 필드명이 중복될 경우 구분하기 위해 사용한다

   this() : 자기자신의 생성자
      생성자 내부에서만 사용가능하며 최상단에 작성해야한다

10. 변수의 종류
   지역변수(local variable)
      클래스 중괄호 영역은 포함되지 않으며, 메소드 또는 생성자 그 안에서 선언된 변수
   매개변수(parameter)
      메소드의 소괄호 안에서 선언되는 변수
   전역변수(global variable) => 필드
      인스턴스 변수
      클래스 중괄호 안에서 선언되는 변수
   정적변수(static variable, clas variable)
      객체간 공유, 편의성을 위해 사용

11. 상속
   재사용, 그룹화

1) 상속
   class A{
      //A클래스의 멤버
   }

   class B extends A{
      //B클래스의 멤버
      //A클래스의 멤버
   }


   A : 부모클래스, 슈퍼클래스, 상위클래스, 기반클래스
   B : 자식클래스, 서브클래스, 하위클래스, 파생클래스

2) super, super()
   super : 부모의 참조값, 부모의 멤버에 접근할 때 사용한다
   super() : 부모의 생성자, 자식클래스 타입의 객체로 부모 필드에 접근할 수 있다
      하지만 자식 생성자만 호출하기 때문에 자식 필드 메모리에 할당된다
      (자식생성자가 부모 생성자를 호출하기 때문에 부모 필드도 메모리에 할당된다)
      즉, 자식 객체를 생성하면 부모 객체도 생성된다

3) 메소드 오버라이딩
   부모 클래스에서 선언한 메소드를 자식 클래스에서 재정의하는 것
   메소드의 선언부가 같아야한다, 구현부는 재정의 가능

4) casting
   Up casting : 자식 값을 부모 타입으로 형 변환
   Down Casting : up casting 된 객체를 다시 자식 타입으로 형 변환

- casting 사용하는 이유
   다양한 타입을 한번에 관리하기 위해 up casting
   up casting 된 자식에서 자식 클래스의 필드나 메소드를 접근해야하는 경우 사용
   다형성

- a instanceof A
   a가 A 타입이면 true, 아니면 false

12. 접근제한자, static, final
1) 접근제한자
   public      : 모든 곳에서 접근 가능, 대표 클래스를 의미할 때 사용
   protected   : 다른 패키지에서 접근 불가, 자식 클래스의 객체 허용
   (default)   : 같은 패키지만 가능
   private      : 같은 클래스에서만 가능, getter/setter

- 클래스의 접근 제한
   적용할 수 있는 접근 제한자 : public, (default)

- 생성자의 접근 제한
   객체 생성을 위해 new 연산자 생성자를 호출해야한다
   생성자가 어떤 접근 제한을 갖느냐에 따라 호출 가능여부가 달라짐
   적용할 수 있는 접근 제한자 : public, protected, default, private
   자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근제한과 동일함

- 필드와 메소드 접근제한
   필드와 메소드 적용할 수 있는 접근제한자 : public, protected, default, private

- getter/setter
   public 접근제한자

2) final
   더 이상 변경이나 수정을 금지할 때 사용하는 키워드
   필드, 메소드, 클래스에서 선언 가능함

- final 필드
   값 변경 불가
   static과 자주 사용된다

- final 클래스
   상속 불가능

- final 메소드
   오버라이딩 불가능

3) static
   static변수/메소드는 객체 생성하지 않아도 사용할 수 있다
   static 변수는 객체와 상관없이 하나의 저장공간이므로 모든 객체게 공유해서 사용한다
   static 메소드는 인스턴스 변수를 사용할 수 없다
   클래스명.변수명

13. 추상클래스, 인터페이스
1) 추상클래스
   추상 메소드를 가지고 있는 클래스

- 추상 메소드
   구현되지 않은 메소드
   abstract 키워드 사용

2) 인터페이스
   interface 키워드를 사용한다
   멤버 : 상수, 추상메소드
   + default, private, static 메소드는 구현된 메소드를 사용할 수 있다

14. 마커인터페이스, 내부클래스, 익명클래스, 람다식
1) 마커인터페이스
   클래스들을 그룹화하기 위한 목적으로 사용하며
   멤버가 없는 인터페이스

2) 내부클래스
   클래스 내부에 선언된 클래스를 의미
   메소드 안에서도 클래스를 선언할 수 있다

3) 익명클래스
   이름이 없는 클래스
   미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해 사용

4) 람다식
   메소드를 하나의 식으로 표현한 것
   익명클래스를 사용하는 방식보다 코드를 줄일 수 있다
   함수형 인터페이스(@FunctionalInterfece)
   - 단 하나의 추상메소드를 가지고 있는 인터페이스
   
15. 예외처리
   예상되는 예외를 적절한 처리를 하여 비정상적인 종료를 막는다

1) try~catch~finally
   try{
      //예외 발생가능성이 있는 코드(실행할 명령문)
   }catch(예외클래스명 객체명){
      e.printStackTrace();   //예외 발생지점을 추적하여 단계별로 전부 출력
      syso(e.getMessage());   //예외 메시지를 문자열로 반환
      syso(e.toString());    //발생한 예외 객체를 문자열로 반환
   }finally{
      //예외 발생 유무에 상관없이 처리될 코드
   }

2) throw, throws
   throws : 예외 던지기, 메소드의 선언부 사용
   throw : 예외 강제 발생시키기

16. Object 클래스, Wrapper 클래스
1) Object 클래스
   최상위 부모 클래스
   .toString() : 객체가 가지고 있는 정보나 값을 문자열로 반환하는 메소드
   .equals() : 클래스의 객체를 비교하고 싶을 때 비교 기준을 재정의하여 사용할 수 있다
      - 주소값을 비교하여 같을 경우 같음을 체크
      - 원하는 값을 비교할 수 있는 조건을 사용하여 같음을 체크
   .hashCode() : 객체의 주소값을 특정 알고리즘을 거쳐 정수값으로 반환한다
      equals()를 재정의하면 hashCode()도 재정의한다

2) Wrapper 클래스
   기본타입      wrapper 클래스
   int      Integer
   long      Long
   double      Double
   float      Float
   boolean      Boolean
   char      Charater
   
   - boxing : 기본 타입의 값을 wrapper 클래스의 객체로 변환
   - unboxing : wrapper 클래스 객체에서 기본 타입의 값으로 변환

17. 컬렉션 프레임워크
   많은 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합

1) 인터페이스
   List   : ArrayList, LinkedList, Vector
      순서 있다, 중복가능
      추가 add
      수정 set
      삭제 remove
      조회 get
   Set   : HashSet
      순서 없다, 중복 불가능
      추가 add

      Iterator 인터페이스
      - iterator() : Iterator 타입으로 변환시 사용
      - hasNext() : 다음 값의 유무를 boolean 타입으로 반환
      - next() : 다음 값을 가져온다, 아무 값도 없으면 예외 발생

   Map   : HashMap
      key-value 한쌍으로 저장, 검색의 목적을 가지고 있다
      서버간 데이터 교환

      추가 put
      조회 get
      
+) JSON
   데이터를 표현하는 방법
   데이터를 저장, 전송할 때 가장 많이 사용되는 형식
      
- Map 형식
   {"key1":value1, ..}   

- ArrayList 형식(JSON 배열 형식)
   [{"key1":value1, ..}, {"key1":value1, ..}]
   

18. 스트림 API
   컬렉션(배열, List, Set 등)의 데이터를 함수형 방식으로 처리하는 API(Java 8부터 도입)

   데이터 소스 -> Stream생성 -> 중간연산 -> 최종연산
         
1) 스트림 생성
- List -> Stream
   List<String> list = Arrays.asList("a", "b", "c");
   Stream<String> stream = list.stream();

- 배열 -> Stream
   int[] arr = {1, 2, 3, 4, 5};
   IntStream stream = Arrays.stream(arr);   

- 직접 생성
   Stream<String> stream = Stream.of("a", "b", "c");

2) 중간연산(여러번 사용 가능)
   filter()    조건에 맞는 요소만 필터링
   map()      요소를 반환
   sorted()   정렬
   distinct()   중복제거
   limit()      개수제한
   skip()      건너뛰기

   stream.limit(3).forEach(System.out::println);
   //앞에서부터 3개

3) 최종연산(한 번만 사용 가능)
   forEach      출력
   collect()   컬렉션으로 반환
   count()      개수 반환
   sum()/average()   합계/평균
   max()/min()   최대값/최소값
   anyMatch()   하나라도true면true
   allMatch()   전부 true면 true
   noneMatch()   전부 false면 true

   
List<String> names = Arrays.asList("홍길동", "홍길순", "이순신", "강감찬");

List<String> result = names.stream()
      .filter(name -> name.startsWith("홍"))
      .map(name -> name + "님")
      .sorted()
      .collect(Collectors.toList())

   ["홍길동님", "홍길순님"]

--------------------------------------------------------------------------------
쓰레드(Thread)

1) 컴퓨터 3계층
   응용 소프트웨어(Application Software) : 사용자가 실제로 사용하는 프로그램
   시스템 소프트웨어(Operating System)
       : 하드웨어를 직접 제어하고 응용 소프트웨어가 하드웨어를 사용할 수 있도록 중간역할을 한다
      Windows, macOS, Linux 등
   하드웨어(Hardware) : 물리적 장치 전체 의미(CPU, RAM, HDD/SSD, 키보드, 모니터, ..)

2) 시스템 자원(System Resource)
   프로그램이 실행되기 위해서는 반드시 OS로부터 자원을 할당받아야한다
   
- 하드웨어 자원
   CPU, RAM(주기억장치), HDD/SSD(보조기억장치), 입출력장치

- 소프트웨어 자원
   파일(File), 소켓(Socket), Signal, 기타 소프트웨어

3) 프로세스(Process)
   OS로부터 시스템 자원을 할당받는 작업의 단위
   프로그램을 실행하면 OS가 RAM에 올리고, CPU 사용권, 파일 핸들 등 시스템 자원을 할당한다
   실행중인 상태를 프로세스라고 한다

   프로그램(HDD에 저장된 .exe, .class 파일)
   ↓ 실행
   프로세스(RAM에 올라간 실행단위, OS가 자원할당)

4) JAVA와 JVM의 관계
   일반 c/c++ 프로그램은 OS가 직접 실행한다
   OS -> 프로그램 실행 -> 시스템 자원 직접 할당

   OS -> JVM 실행 -> JVM이 Java 프로그램 실행 -> 자원은 JVM을 통해 간접 할당

- JVM(Java Virtual Machine)
   java 바이트코드를 해석해서 실행하는 가상 머신
   JVM 자체가 하나의 프로세스로 OS에서 실행되고 JAVA프로그램은 그 JVM 위에서 동작한다
   Java는 OS에 독립적이다
      
   Write Once, Run Anywhere

5) 쓰레드와 JVM 관리
   프로세스 내에서 실제 작업을 수행하는 실행 흐름의 단위
   하나의 프로세스 안에 여러 쓰레드가 존재할 수 있고 쓰레드들은 프로세스의 메모리자원(Heap, Method Area)을 공유함
   
프로세스(jvm)
   |- Thread-1 ( main 메소드 실행 ) 
   |- Thread-2 ( 추가작업 )
   |- Thread-3 ( 추가작업 )
   |_ 공유 메모리 : Heap, Method Area
     각 쓰레드 개별 : Stack, PC Register

[하드웨어]  cpu, RAM, I/O
    직접 제어
[운영체제]  Windows
    시스템 자원 할당
[JVM]   하나의 프로세스
    바이트코드 해석 및 실행, 쓰레드 관리
[Java Application] main(), Thread, 객체들..


6) 싱글 쓰레드
   하나의 쓰레드가 작업을 마치면 프로그램이 종료한다
   쓰레드를 하나만 가지고 있기 때문에 작업을 순차적으로 처리하므로 상대적으로 비효율적이다
   쓰레드는 자원을 사용하는데 싱글 쓰레드는 혼자서 자원하므로 동기화를 걱정할 필요가 없다
   따라서 안정성이 높고 설계가 쉽다

7) 멀티 쓰레드
   메인쓰레드가 작업을 마치더라도 다른 쓰레드의 작업이 모두 끝나야 프로그램이 종료된다
   하나의 프로세스에서 여러 작업을 동시에 처리하는 것처럼 느껴지지만 사실은 각각의 쓰레드를
   매우 빠른 속도로 번갈아가며 실행시켜서 조금씩 처리한다
   쓰레드간 공유하는 자원이 있다면 충돌이 생겨 문제가 생길수있으며 이런 문제를 동기화(Synchronized)를 통해 해결한다
   안정성이 떨어지고 설계가 굉장히 어렵다
