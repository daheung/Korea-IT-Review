day10(java 8일차)

* 지각자 : 홍성인, 김재형, 김태우, 서정원, 박지수, 김재민
* 결석자 : 송창훈

260113 한컴타자연습
한타 : 현대시_김영랑
영타 : Row Row Row your Boat
------------------------------------------------------------
복습 -> 메소드2 -> 클래스1

0. 복습
1) 배열(Array)
	같은 타입의 값 여러개를 연속적으로 관리하는 자료구조
	인덱스로 접근하며 0부터 시작
	길이 고정 : 한 번 생성 후 크기 변경 불가(새로운 배열을 만들어야함)

2) 배열 선언/생성/초기화
[1차원]	
- 칸 수를 알 때(값은 모름)
	자료형[] 배열변수 = new 자료형[배열길이];
- 값을 이미 알 때
	자료형[] 배열변수 = {값1, 값2, ..};
- 참조만 선언하고 나중에 만들 때
	자료형[] 배열변수 = null;
- 선언 후 생성 + 초기화
	자료형[] 배열변수;
	배열변수 = new 자료형[]{값1, 값2};

[2차원]
- 칸 수를 알 때(값은 모름)
	자료형[][] 배열변수 = new 자료형[행][열];
	자료형[][] 배열변수 = new 자료형[행][];

	int[][] arr = new int[3][];
	arr[0] = new int[1];
	arr[1] = new int[2];
	arr[2] = new int[3];

- 값을 이미 알 때
	자료형[][] 배열변수 = {{값1, 값2, 값3}, {값1, 값2, 값3}};
	자료형[][] 배열변수 = {{값1, 값2}, {값1}};

3) new 의미
	heap에 객체(배열 포함)를 생성한다

	int[] arr = new int[5];

- 배열 생성 과정
		
	힙에 int[5] 공간 확보
	각 요소 기본값으로 초기화
		int 0, boolean false, 참조형 null
	힙에 생성된 배열의 참조값(reference)을 반환
	그 참조값을 스택의 변수(arr)에 저장

4) index와 length
	index : 각 칸의 번호(저장공간의 번호) 0부터 시작한다
		arr[0], arr[1]
	length : 배열 칸 수
		arr.length

5) 2차원 배열(가변배열과 정형배열)
	정형 : 모든 행의 열 길이가 동일
	가변 : 행마다 열 길이가 다를 수 있음

6) 향상된 for문(for-each문)
	for(자료형 변수명 : 배열/컬렉션){
		//변수는 배열이나 컬렉션 요소 1개씩 받음
	}

- 장점
	코드가 짧고 가독성이 좋음
	인덱스 범위 오류가 줄어듦

- 한계
	인덱스 필요하면 부적합
	배열 요소를 교체하는 방식의 수정에는 부적합
	
7) 삽입정렬(Insertion Sort)
	정렬이 되어있다고 가정하고 현재 값을 적절한 위치에 끼워 넣음
	거의 정렬된 데이터에서 빠름
- 구현
	key 저장
	큰 값들을 오른쪽으로 밀기
	빈 자리에 key 삽입

8) 선택정렬(Selection Sort)
	전체에서 최솟값이나 최댓값을 찾아 앞자리(뒷자리)와 교환
	비교가 많음, 교환횟수는 상대적으로 적음
	불안정정렬(같은 값의 상대 순서가 깨질 수 있음)

9) 버블정렬(Bubble Sort)
	인접한 두 값을 비교하며 큰 값을 뒤로 보내기
	직관적이지만 비효율적
	안정정렬(같은 값의 상대 순서가 깨지지 않음)

10) Arrays.sort(배열)
	Arrays.sort(int[]) 기본형 배열 => Dual-Pivot Quicksort(자바구현에서 사용되는것) 계열이 사용됨
	Arrays.sort(Object[]) 객체 배열 => TimSort(병합 + 삽입 기반, 안정정렬) 사용

    Arrays.toString / deepToString
	Arrays.toString(int[]) -> 1차원 배열 출력에 적합
	Arrays.deepToString(Object[]) -> 다차원(특히 2차원이상) 출력에 적합

11) 메소드
- 메소드 정의 
	클래스 내부, 다른 메소드 밖(중괄호 밖)

	리턴타입 메소드명(자료형 매개변수) 	//선언부
	{				//구현부
		실행할 문장;
		return 값; //리턴타입이 void면 return 생략가능
	}

- 메소드 호출(4가지)
	어떤 메소드 내부(보통 main 또는 다른 메소드 내부)

	매개변수	리턴값	호출방식
	x	x	.메소드명();
	o	x	.메소드명(인수);
	x	o	syso(.메소드명());	자료형 변수명 = .메소드명();
	o	o	syso(.메소드명(인수));	자료형 변수명 = .메소드명(인수);

+) static 때문에 생기는 오류
	main 메소드 static이다
	static 메소드 안에서는 같은 클래스의 인스턴스(객체) 멤버를 바로 못 부른다
	- 인스턴스 메소드는 객체가 있어야 존재한다

why?
	프로그램 시작 시 main은 객체 없이도 실행되어야 한다
	인스턴스 메소드는 new로 객체를 만들기 전엔 사용할 대상이 없다

해결방안 2가지
	메소드 정의 시 static 붙이기 -> 클래스 차원에서 바로 호출 가능
	객체를 만들어서 호출하기 -> 인스턴스 메소드로 유지하고 싶을 때

+) 메소드와 메모리
	지역변수/매개변수 : 스택 프레임
	new로 만든 배열/객체 : 힙
	static 멤버/클래스 정보 : 메소드 영역(메타스페이스)

1. 메소드
1) 메소드와 메모리
	메소드는 실행되면 메모리의 stack 영역에 메소드 실행에 필요한 저장공간이 생긴다
	그 곳에 메소드 내부에서 선언한 변수(매개변수, 지역변수)들의 저장공간이 생긴다
	메소드의 코드가 모두 실행되어 종료되면 stack 영역에서 해당 메소드의 저장공간이 삭제된다(메모리 해제)
	그러면 지역변수의 저장공간이 사라지므로 지역변수는 더 이상 사용이 불가능하다

+) 스택 프레임의 장점
	메모리 관리 효율성 : 메소드를 호출할 때 필요한 메모리를 동적으로 할당하고, 호출이 끝나면 자동으로 해제된다
	재귀적 호출 지원 : 재귀호출에 각 호출마다 독립적인 스택 프레임이 생성되어 서로 간섭없이 수행된다
	지역성 : 스택 메모리의 접근 속도가 빠르며 지역변수와 매개변수는 메모리 접근 비용이 적다

2) 메소드의 사용 이유
	중복된 코드 제거
	높은 재사용성
	유지보수에 유리함

3) 인수와 매개변수
	인수(Argument) : 메소드를 사용(호출) 할 때 메소드의 매개변수로 전달될 값
	매개변수(Parameter) : 외부에서 전달받아 값을 저장하고 메소드 내에서 사용될 변수

	- 메소드의 인수와 매개변수는 반드시 타입과 일치하거나 자동 형변환이 가능한 타입이어야한다
	- return되는 값은 return 타입과 일치하거나 자동 형변환이 가능한 타입이어야한다

4) 메소드 오버로딩(Method Overloading)
	다형성 : 같은 코드로 다른 기능 하는 것
	Method : 작업을 수행하는 코드블록
	Overloading : 과부하, 너무 많이 실음이라는 의미
		프로그래밍에서는 같은 이름을 여러번 사용하는 것을 의미

	같은 이름의 메소드를 여러개 정의하는 것을 의미한다
	매개변수의 개수, 타입, 순서가 다르면 같은 이름의 메소드로 선언할 수 있다
	리턴타입은 메소드 오버로딩에 전혀 영향을 주지 않는다

- 메소드 오버로딩 조건
	리턴타입 같아도 상관없음
	메소드 이름은 같아야함
	매개변수의 순서, 개수, 타입이 달라야함

- 메소드 오버로딩 시 주의사항
	매개변수의 타입, 순서, 개수가 동일한 경우 매개변수의 이름이 다르다고해서 오버로딩이 아니다
	리턴타입만 다르고 메소드의 이름과 매개변수가 동일한 경웅에도 오버로딩이 아니다

- 메소드 오버로딩이 필요한 이유
	이름의 통일성 : 비슷한 작업을 수행하는 메소드는 같은 이름을 사용하면 직관적이다
	코드 가독성 : 여러 작업을 하나의 이름으로 처리할 수 있어 코드가 간결해진다
		(메소드 이름을 따로 기억할 필요가 없다)

- 메소드 오버로딩이 가능한 이유
	컴파일러가 메소드를 호출 시 메소드 이름 뿐만아니라 매개변수의 정보를 사용해 정확히 어떤 메소드를 호출할 지
	구분하기 때문이다

	컴파일 시 메소드 이름이 다르게 지정됨
		컴파일러는 메소드의 이름과 매개변수의 정보를 합쳐서 고유한 시그니처(Method Signature)를 생성
		시그니처는 메소드명 + 매개변수의 타입과 개수로 구성

- 컴파일러가 메소드를 선택하는 과정
	매개변수의 개수 확인 : 메소드 호출 시 인수값의 개수와 일치하는 메소드를 먼저 찾는다
	매개변수의 타입 확인 : 메소드 호출 시 전달된 인수값의 타입과 일치하는 메소드를 찾는다
	타입 변환 규칙 적용 : 전달된 인수값의 타입과 정확히(완전히)일치하는 메소드가 없을 경우,
		더 큰 타입으로 변환 가능한 메소드를 호출(작은 타입의 값은 큰 타입으로 자동 형변환이 가능하기 때문)
		int -> long, float, ddouble 순으로 자동 변환 가능
		큰 타입이 호출 우선순위의 뒤에 있다

+) StackOverflow
	스택(Stack)메모리의 한계를 초과해서 사용했을 때 발생하는 오류
	- 프로그램 실행 중 스택 메모리가 가득차서 더이상 할당할 수 없을 때
	- 주로 무한 재귀 호출, 과도한 지역변수, 잘못된 함수(메소드)호출 구조에서 발생

- Stack의 역할
	메소드 호출 정보 저장 : 매개변수, 지역변수, 반환 주소
	List In First Out(LIFO 구조)

- 보안관점
	메모리 침범(Memory Corruption)
	특히 C/C++에서 치명적인 오류

- 공격흐름
	공격자가 의도적으로 긴 입력값을 전달
	스택 버퍼 크기 초과
	리턴 주소(Return Address) 덮어쓰기
	공격자 코드 실행

- 결과
	임의 코드 실행(RCE)
	권한 상승
	시스템 장악
	서비스 거부(DoS)

2. call by value와 call by reference
	=> 메소드 호출 시 매개변수를 전달하는 방식

1) Call by Value(Pass by Value)	: 값에 의한 호출
	값을 복사하여 메소드에 전달하는 방식
	메소드 호출 시 원본 값이 복사되므로 메소드 내부에서 값이 변경되어도 원본에는 영향을 미치지 않음

	메소드 호출 시 인수로 전달되는 것은 변수의 값 자체
	- 기본 데이터 타입에서 사용
	- 메소드 내부에서 값을 변경해도 원본 변수는 변경되지 않음

2) Call by Reference(Pass by Reference) : 참조에 의한 호출
	참조를 전달하여 메소드에 직접 원본 데이터를 조작할 수 있는 방식
	메소드 호출 시 데이터의 주소(참조값)가 전달되므로, 메소드 내부에서 데이터를 변경하면 원본 데이터도 변경됨

	- 메소드 내부에서 참조된 객체를 수정하면 원본 객체도 변경됨
	- C++ 등의 언어에서 지원되며, JAVA 지원되지 않음

			기본데이터타입		참조데이터타입
전달방식			값 자체를 복사해서 전달	참조값(주소)을 복사해서 전달
원본데이터변경여부		메소드 내부 변경이 원본에 영향없음	참조된 객체를 변경하면 원본 객체에도 영향있음
참조값 변경여부		의미없음			참조값 자체를 변경해도 원본 참조값에는 영향없음

+) Java 동작
	Java는 항상 Call by Value로 동작한다
	기본 데이터 타입 : 값 자체가 복사되어 전달
	참조타입 : 객체의 참조값이 복사되어 전달되므로 객체 내부의 데이터는 수정할 수 있지만 참조값 자체는 변경되지 않는다
	※ 참조 타입의 동작이 Call by Reference 처럼 보일 수 있지만 실제로는 참조값의 복사(Call by Value)이다

	기본 데이터 타입 : stack 메모리에 값 자체가 저장된다
	참조타입 : stack 메모리에 참조값이 저장되고 객체 자체는 heap 메모리에 저장된다

+) 복사
	얕은복사(Shallow Copy) : 참조값이 복사됨(원본과 복사본이 서로 의존적)
		속도 빠름, 메모리 사용량이 적음, 간단한 객체나 데이터 구조
	깊은복사(Deep Copy) : 모든 데이터가 복사됨(원본과 복사본이 서로 독립적)
		데이터 양에 비례하여 속도 느림, 메모리 사용량이 많음, 데이터의 독립성이 중요

		call by value	call by reference
값전달		값 복사		주소 전달
원본변경		X		O
java 지원	O		X
C/C++ 지원	O		O
참조형 동작	주소값 복사	실제 주소 공유

	JAVA의 참조형은 Call by Reference 처럼 보이지만 Call By Value로 동작한다
	
3. 객체 지향 언어(OOP, Object-Oriented Programming)
	프로그램을 객체로 구성하고 이 객체들 간의 상호작용을 통해 문제를 해결하는 방식

1) 캡슐화(Encapsulation)
	객체의 데이터를 보호하고 외부에서 접근할 수 있는 방법을 제한하는 개념
	객체 => 데이터를 포함한 속성과 동작을 정의하는 메소드를 하나로 묶은 것을 의미
	객체 외부에서 내부 데이터를 직접 변경하지 못하게 하고 허용된 메소드를 통해서만 데이터를 변경하거나 사용할 수 있게 한다
	데이터(필드)를 private 접근 제한자를 선언하여 외부에서 직접 접근하지 못하게 하고 
	getter, setter 메소드를 통해서만 필드에 접근하도록 한다

2) 다형성(Polymorphism)
	다형성을 통해 같은 이름의 메소드가 객체에 따라 다르게 동작하는 것을 의미
	메소드 오버로딩, 메소드 오버라이딩, 참조변수의 다형성

3) 상속(Inheritance)
	기존 클래스의 필드와 메소드를 자식 클래스가 물려받아 쓰는 것을 의미(상속을 지원한다)
	상속은 extends 키워드를 사용한다
	단일 상속만 지원한다(한번에 하나의 부모클래스만 상속 가능)

4) 추상화(Abstraction)
	불필요한 세부 구현을 숨기고 중요한 부분만 노출하는 것을 의미
	추상클래스, 인터페이스

5) 클래스와 객체
	추상화된 클래스로 객체를 만들고 객체들간의 관계를 맺어 상호작용하는 프로그래밍 기법
	추상화(객체모델링) : 공통적인 특징을 파악하여 하나의 묶음으로 만들어 내는 것

4. 클래스1
0) 쉽게 설명
- 클래스		비슷한 특징을 가진 것들을 묶어서 만든 일종의 설계도면
		사람클래스, 동물클래스, 탈것클래스
- 클래스 안에 있는 것?	설계도면에 따라 만들어진 물건들을 위한 특징(속성, 필드)과 물건이 할 수 있는 행동(메소드)
		사람클래스 => 필드 : 이름, 나이, 핸드폰번호, 주소, 혈액형,...
			메소드 : 걸을 수 있다, 전화할 수 있다, 잘 수 있다, 공부할 수 있다, 말할 수 있다
- 속성?		사람이 가진 특징 => 이름, 나이, 핸드폰번호, 아이디, 비밀번호...
- 메소드?		사람이 할 수 있는 행동 => 걷기, 말하기, 먹기, 공부하기, ..
- 객체?		클래스를 만들면 설계도면에 따라 실제 물건(객체)를 만들 수 있다
	사람클래스 => 영선 객체명을 가진 사람을 만들 수 있고, 짱구 객체명을 가진 사람을 만들 수 있다
		각 사람은 자신의 특징을 가지고 있고 행동을 할 수 있다

1) 클래스
	사용자 정의 타입으로 데이터(필드)와 기능(메소드)를 함께 묶어 관리하는 설계도이다
	클래스를 사용하면 다양한 데이터를 저장하고 관리 할 수 있는 객체를 생성할 수 있다

2) 클래스의 특징
- 사용자 정의 타입이다(자료형)
	클래스를 사용하면 여러 타입, 여러 값을 저장할 수 있는 저장공간을 만들 수 있다
	클래스 안에 선언되어 있는 변수를 사용하고 싶다면 해당 클래스 타입으로 변수를 선언해야한다

	변수 : 하나의 자료형으로 하나의 값만 저장할 수 있는 저장공간
	배열 : 하나의 자료형으로 여러 값을 저장할 수 있는 저장공간

- 연관성 있는 저장공간과 기능을 한 곳에 모아 편하게 관리할 수 있다
	저장공간과 기능을 나누어 관리하게 되면 코드가 길어졌을 때 사용하기 불편하다
	이 때 연관성 있는 저장공간과 기능을 클래스로 묶어서 관리할 수 있다

- 객체를 생성하기 위한 틀, 설계도(면)
	공통되는 속성(변수, 필드)과 행위(기능, 행동, 메소드)를 한 번만 선언 해 놓고 가져다 사용만 할 수 있도록 설계한다
	추상적인 것(클래스)를 구체화 시키면(메모리에 생성한 것) 객체라고 한다

3) 객체(Object)와 인스턴스(Instance)
- 객체(Object)
	현실 세계의 사물 또는 개념
	속성(상태)과 기능(행동)을 가짐

	사람, 자동차, 은행계좌, 학생정보 => 아직 메모리와는 직접적인 관련 없음

- 클래스(Class)
	객체를 만들기 위한 설계도
	객체의 속성과 행동을 정의
	실제 존재하는 대상 x

	메모리에 객체를 생성하기 위한 틀
	여러 객체를 만들 수 있음
	하나의 클래스 -> 여러 인스턴스 가능

- 인스턴스(Instance)
	클래스를 기반으로 메모리에 생성된 실체
	물리적으로 존재하는 객체
	구체적인 상태 값을 가짐

	new 키워드로 생성
	Heap 메모리에 할당
	클래스 설계대로 만들어짐

+) 객체 vs 인스턴스
	객체(Object)	인스턴스(Instance)
의미	개념적 대상	메모리에 생성된 실체
관점	현실/논리적	메모리/물리적
사용시점	포괄적 개념	클래스에서 생성됨을 강조
관계	인스턴스를 포함하는개념	객체의 한 형태

현실세계의 개념
    ↓
객체 (Object)
    ↓	추상화
클래스(Class)
    ↓ new
인스턴스(Instance)

4) 클래스 선언
	class 클래스명{
		//class를 구성하는 필드와 메소드를 합쳐서 멤버라고 부른다

		필드;	// 멤버변수, 전역변수

		메소드(){} //멤버 메소드
	}

- 객체화(인스턴스화)
	객체를 만드는 작업, 추상적인 개념을 구체화 시키는 작업

	클래스명 객체명 = new 클래스명();
	클래스명 참조변수 = new 생성자();

- 객체 멤버 접근 방법
	.	하위 연산자, 멤버 접근 연산자, 닷 연산자(~의, ~안에)
	
	참조변수.필드명

	메소드 호출방법 4가지
	매개변수 x, 반환값 x	=>	참조변수.메소드명();
	매개변수 o, 반환값 x	=> 	참조변수.메소드명(인수);
	매개변수 x, 반환값 o	=> 	syso(참조변수.메소드명());
					자료형 변수명 = 참조변수.메소드명(); 
	매개변수 o, 반환값 o	=>	syso(참조변수.메소드명(인수));
					자료형 변수명 = 참조변수.메소드명(인수);

+) 객체를 생성하고 참조 변수에 저장되는 과정

	class MyClass{
		void myMethod(){}
	}

	public class Main{
		main(String[] args){
			MyClass m = new MyClass();
			---------   --------------
			1번		2번
				 ---
				 3번
		}
	}

1번 : m이라는 참조 변수는 main()메소드 영역에 만들어진 지역변수이므로 JVM이 관리하는 메모리의 stack 영역에 생성된다
	데이터 타입은 참조하려는 대상과 같은 자료형이어야하므로 MyClass라고 지정한다

2번 : new 키워드가 heap 메모리에 MyClass 객체를 생성하고 참조값을 가져온다
	이 때 생성자가 실행된다

3번 : 대입연산자를 통해 오른쪽의 참조값을 왼쪽의 참조 변수에 저장한다(대입한다)

























