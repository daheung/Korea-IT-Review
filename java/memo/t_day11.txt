day11(java 9일차)

* 지각자 : 송민진, 홍성인, 이주환, 김재민
----------------------------------------------------------------------------
9시 30분 	4팀
10시 		2팀
10시 15분  	1팀
10시 30분	3팀

결과 실행은 모든 팀원 설명 후 진행

배열 코드 구현
현재 팀 메소드로 기능 분리(내일 오전 9시까지 제출)
내일 오전 자리 변경
-------------------------------------------------------------------------
260114 한컴타자연습
한타 : 애국가 1절
영타 : Dokdo

복습 -> 생성자 -> 오버로딩 -> this, this() -> static

0. 복습
1) 메소드
	하나의 기능을 하는 코드 블록

- 메소드 정의
	메소드 중괄호 밖에서 정의
	리턴타입 메소드명(자료형 매개변수){
		실행문;
		return 리턴값;
	}

- 메소드 호출방법
	매개변수	리턴값	호출
	x	x	객체명.메소드명();
	o	x	객체명.메소드명(인수);
	x	o	syso(객체명.메소드명());	
			자료형 변수명 = 객체명.메소드명();
	o	o	syso(객체명.메소드명(인수));
			자료형 변수명 = 객체명.메소드명(인수);

- 메소드 오버로딩(다형성)
	하나의 메소드명으로 매개변수의 개수, 순서, 타입이 다를 때 정의할 수 있는 것을 의미

- 메소드를 사용하기 위한 2가지 방법
	메소드를 정의할 때 선언부 static 키워드를 붙인다
	클래스의 객체를 만들어서 사용한다

	클래스타입 객체명 = new 클래스명();
	클래스타입 참조변수 = new 생성자();
	--------------	 ------------
	stack		  heap

2) 클래스
- 클래스 특징
	사용자 정의 타입이다
	연관성있는 저장공간과 기능을 한 곳에 모아 관리 가능
	객체를 만들기 위한(생성하기 위한) 틀

- 클래스 선언
	class 클래스명 {
		//필드;
		//메소드(){}
	}

- 객체화(인스턴스화)
	클래스타입 객체명 = new 클래스명();
	클래스타입 참조변수 = new 생성자();

- 클래스 멤버에 접근
	객체명.필드명 = 값;
	syso(객체명.필드명);

	객체명.메소드명();			매개변수 x	리턴값 x
	객체명.메소드명(인수1, 인수2, 인수3);	매개변수 o	리턴값 x
	syso(객체명.메소드명());		매개변수 x	리턴값 o
	syso(객체명.메소드명(인수1, 인수2));	매개변수 o	리턴값 o

1. 생성자(Constructor)
	클래스이름 뒤에 소괄호가 있는 형태
	생성자는 리턴이라는 기능이 존재하지 않기 때문에 메소드와 비슷하지만 메소드라고 부르지 않는다
	객체가 생성될 때 자동으로 실행되고, 주로 클래스의 필드를 초기화할 때 사용한다

	- 생성자는 클래스이름과 동일한 이름을 가지며, 반환값이 없는 특별한 메소드이다

1) 생성자의 특징
	클래스 이름과 동일한 이름을 사용한다
	반환타입을 명시하지 않는다(void도 사용하지 않는다)
	객체를 생성 시에 new 키워드를 통해 호출되며 직접 호출할 수 없다
	생성자를 정의하지 않으면 기본생성자(매개변수가 없는 생성자)가 자동으로 추가가 된다(컴파일러가 추가해준다)
	하지만 개발자가 생성자를 하나라도 정의하게 되면 기본 생성자는 자동으로 만들어지지 않는다

2) 기본생성자
	public 클래스명(){}
	매개변수가 없다
	클래스 선언 시 자동으로 선언되며 사용자가 직접 생성자를 선언하게 되면 자동으로 만들어주지 않는다

3) this
	객체 자기자신, this는 자동으로 생성되는 변수
	현재 객체 자신을 참조하는 특별한 키워드
	클래스 내부에서 필드와 메소드를 가리킬 때 사용된다

- this 키워드를 사용하는 이유
	필드와 매개변수의 이름이 동일할 때 구분
	가독성 향상
	다른 생성자 호출 및 메소드 체이닝 구현

4) 생성자 오버로딩
	하나의 클래스에 여러개의 생성자를 정의할 수 있다
	각 생성자는 매개변수의 개수, 타입, 순서가 달라야한다
	객체를 만들 때 상황이 다르기 때문에 => 필요한 정보만 받아서 객체를 유연하게 생성 가능

5) this()
	자기자신의 생성자
	생성자 내부에서만 사용가능하며 최상단(첫번째 줄)에 작성해야한다
	-> 생성자 내부에서 나의 다른 생성자를 호출할 때 사용한다
	

+) 생성자별 동작
- 기본 생성자
	public Person(){}
	아무것도 초기화하지 않음
	필드는 기본값(null, 0, 0.0, false 등)

	new Person();		
		
- 이름만 받는 생성자
	public Person(String name){
		this.name = name;
	}
	이름만 초기화

	new Person("홍길동");

- 이름 + 나이
	public Person(String name, int age){
		this(name);
		//this.name = name;
		this.age = age;
	}
	Person(String name);
	name 초기화
	돌아와서 age 초기화
	=> 중복 제거

	new Person("홍길동", 20);

- 이름 + 직업
	public Person(String name, String job){
		this(name);
		this.job = job;
	}
	이름 초기화 로직 재사용

	new Person("홍길동", "개발자");

- 이름 + 나이 + 직업
	public Person(String name, int age, String job){
		this(name, job);	//Person(String name, String job)
		this.age = age;
	}
	Person(String name, String job)
	내부에서 this(name) -> name 초기화
	돌아와서 job 초기화
	다시 돌아와서 age 초기화 
	
	new Person("홍길동", 20, "개발자");


	public Person(String name){
		this.age = 20
		this.job = "학생";
	}

+) 다양한 초기화 방식을 활용할 경우의 장점
	유연성 : 객체 생성 시 입력할 데이터에 따라 적절한 생성자를 사용가능
	코드 재사용 : 같은 클래스 내에서 다양한 초기화 방법을 제공하여 코드의 중복을 줄임
	가독성 : 생성자를 호출하는 코드에서 어떤 값이 초기화되는지 명확히 알 수 있음














































