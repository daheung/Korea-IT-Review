day04 (java 2일차)
복습 -> 자료형과 변수 -> 제어문자, 출력메소드, 서식문자 -> 형변환

26/1/5 한컴타자연습
한타 : AI 창작동화(주제 : 그림자)
영타 : Landmark

0. 복습
1) 컴퓨터
	컴퓨터 : 하드웨어 + 운영체제(OS) + 소프트웨어
	컴퓨터 언어 : 저급언어 ---- 고급언어
	번역프로그램 : 컴파일러, 인터프리터
	
2) 자바프로그램
	.java 파일 ----> .class ----> 실행결과
		javac.exe     java.exe


	java프로젝트 -> 패키지 -> 클래스 -> main 메소드

3) jvm, jre, jdk
JVM(Java Virtural Machine)
	운영체제에 맞춰서 java로 만든 프로그램을 실행시켜준다

JRE(Java Runtime Enviroment)
	JVM을 실행한다
	JVM을 실행할 때 필요한 라이브러리 파일 등을 가지고 있다

JDK(Java Devlopment Kit)
	JRE을 포함한다
	JRE외에 개발에 필요한 도구들을 가지고 있다

4) 이클립스 단축키
프로젝트, 패키지, 클래스 생성
	ctrl + n
메인 메소드 생성
	프로젝트 생성 시 alt + v, 클래스 파일의 {}영역안에서 main 메소드 생성
	클래스 파일의 {} 영역안에서 main + ctrl + space bar 엔터
출력 메소드 생성
	syso + ctrl + space bar 엔터
저장
	ctrl + s
실행
	ctrl + F11
라인 한 줄 복사
	ctrl + alt + 방향키 위/아래
라인 한 줄 이동
	alt + 방향키 위/아래
F2
	파일명, 패키지명, 프로젝트명 변경
자동정렬
	ctrl + shift + f

5) 용어 정리
자바프로젝트
	하나의 프로그램 단위
	프로그램을 구성하는 것들을 모아둔 폴더
패키지
	소스파일들의 묶음 단위
	프로젝트의 하위 폴더
소스파일
	.java로 끝나는 파일이며 소스코드가 작성된다
	이클립스에서는 클래스파일을 생성하면 자동으로 클래스와 같은 이름으로 소스파일을 만들어준다
클래스
	자바에서 모든 코드는 클래스 내부에서 작성된다
	클래스 이름 첫글자를 대문자로 작성해야한다
중괄호{}
	영역을 표시한다
메소드
	이름뒤에 소괄호()가 있는 대부분의 명령어는 메소드이다
	키워드 뒤에 ()가 있는 명령어는 메소드가 아니다(ex : for(){}, if(){} ..)
콘솔창
	입력과 출력이 가능한 창
	컴퓨터와 개발자가 의사소통을 할 수 있는 창
	개발자가 제대로 된 코드를 작성했는지 확인하기 위해서 사용한다
.(닷 연산자, 하위 연산자)
	~안에 라고 해석한다
	System.out.println();
세미콜론 ;
	문장의 끝을 표시한다
들여쓰기
	가독성을 높이기 위해서 사용한다
주석
	코드에 영향을 끼치지 않는다
	내가 쓴 코드를 다른 사람에게 설명하기 위한 설명글
	잠시 일부 코드를 제외하고 실행시켜야할 때
	★ 자바 배울 동안은 주석을 통해 코드해석, 로직구성을 필수로 진행한다!!
	한줄 주석		//(ctrl + /)
	여러줄주석(범위주석) /* */(ctrl + shift + /, ctrl + shift + \)
	api주석		/** */

1. Java란
1) java 개발 배경
	1995년 공식 발표, sun 마이크로시스템사 제임스 고슬링 팀이 1991년에 개발 시작
	
	목적 : 가전제품을 제어할 수 있는 이식성이 높은 언어 개발
		이후 인터넷 시대와 맞물리며 웹 프로그래밍 언어로 급부상
	특징 : 객체 지향 프로그래밍(OOP) 언어
		C, C++의 문법을 기반으로 개발
		-> 포인터 제거, 메모리 자동 관리 등으로 안정성과 이식성 강화
	이름이유 : Oak(오크) 상표로 등록된 이름이라 사용 불가능
		-> java(커피) 이름 채택

2) Java 주요 특징
객체지향언어(OOP : Object-Oriented Programming)
	모든 것이 객체로 구성됨(클래스, 객체, 상속, 다형성, 캡슐화 등)
	유지보수와 확장성이 뛰어남
플랫폼 독립성(Platform Indepedence)
	JVM(Java Virtual Machine) 위에서 실행됨
	Write Once, Run Anywhere => 한 번 작성하면 어디서든 실행 가능
자동 메모리 관리(Automatic Memory Management)
	가비지 컬렉터(Garbage Collector)가 불필요한 메모리 자동 정리
	개발자가 직접 메모리를 해제할 필요가 없음 -> 메모리 누수 방지
보안성(Security)이 뛰어남
	JVM의 샌드박스 구조로 시스템 자원에 대한 접근 제한
멀티쓰레드 지원(Multi-Threading Support)
	하나의 프로그램 내에서 여러 작업을 동시에 처리 가능
풍부한 라이브러리 제공
	jre 라이브러리 만으로 처리 가능
	java.util, java.io, java.net 등 방대한 API 제공
배우기 쉬움(Simple & Familiar)
	c/c++기반의 문법이라 익히기 쉬움
	포인터 제거, 메모리 수동 관리 제거 -> 복잡성 감소
동적 로딩(Dynamic Class Loading)
	실행 시 필요한 클래스만 동적으로 로딩하여 메모리 효율적 사용
	프로그램의 유연성과 확장성 향상

2. 자료형(Data Type) : 값의 타입
	자료형	type	byte	값의 의미			예시
	정수형	int	4byte	양의정수, 음의정수, 0	2, -15, 0, 2525222, ...
		long	8byte	양의정수, 음의정수, 0	2L, -15L, 0L, ...
	실수형	double	8byte	소수점이 있는 수		3.14, 5.1, -252.1411, 0.0, ...
		float	4byte	소수점이 있는 수		3.14f, 5.1f, -252.1411f, 0.0f, ..
	논리형	boolean	1byte	참, 거짓			true, false
	문자형	char	2byte	문자1개(' ')		'a', '가', '0', ' ', ...
	문자열	String	?	문자열의 나열("") 0개이상의 문자	"", "a", "김영선", "2026년 1월 5일입니다", ..

bit(비트)
	컴퓨터가 처리할 수 있는 최소의 데이터 단위
	0, 1

byte
	bit를 8개 묶어서 1byte

문자
	작은따옴표로 감싸진 1개의 문자

문자열
	문자들의 나열
	큰 따옴표로 감싸진 0개 이상의 문자

3. 변수(Variable)
	어떤 값을 저장하기 위한 저장공간

1) 변수의 특징
	변수는 오직 하나의 자료형만 저장할 수 있다
	변수는 오직 하나의 값만 저장할 수 있다
	=> 하나의 자료형과 하나의 값만 저장할 수 있는 저장공간

2) 변수의 선언과 사용
	변수의 선언(만든다)
		자료형 변수명;
		변수명 : 저장공간의 이름
		
		int number;
		char alpha;
		boolean isTrue;

	변수에 값을 저장(변수 초기화)
		변수명 = 값;
		= 대입연산자	오른쪽의 값을 왼쪽의 저장공간에 저장한다(대입한다)

		number = 10;
		alpha = 'a';
		isTrue = true;

	변수 선언과 동시에 초기화
		자료형 변수명 = 값;

		int number2 = 100; //정수형 변수 number2를 선언하고 100이라는 값을 저장한다

	변수에 저장된 값을 사용하는 방법
		변수명을 이용한다
		=> 변수안에 저장된 값이 출력된다

	여러개의 변수를 선언하는 방법
		동일한 자료형 일 때만 가능
		자료형 변수명1, 변수명2, 변수명3, ...;

		int num1=1, num2=2, num3=3;
		char alpha1, alpha2;
		String name, grade;

3) 변수 선언 시 주의사항
	같은 영역(중괄호)에서 같은 이름의 변수를 선언할 수 없다
		int age = 20;
		int age = 30; (x)
	되도록 변수는 소스코드 위쪽에 한꺼번에 선언한다
		int age = 10;
		double height = 150.5;
		double weight = 49;
	되도록 선언과 동시에 초기화 한다
		boolean isStudent = true;
	
4) 변수명 주의사항
	문자로 시작해야한다(숫자로 시작 불가능)
		int age;  (o)
		int _age; (o)
		int $age; (o)
		int 1age; (x)
	특수문자는 사용할 수 없다(단, _와 $는 가능)
		String user_name; (o)
		String user-name; (x)
		String user@name; (x)
	공백을 사용할 수 없다
		int user age; (x)
		int userAge;  (o) 카멜표기법
		int user_age; (o) 가능하지만 상수를 표현할 때 쓰므로 변수 선언시에는 카멜표기법을 이용한다
		int UserAge; (o) 가능하지만 변수 선언시에는 카멜표기법을 이용한다
	키워드(예약어)는 사용할 수 없다
		int int; (x)
		int class; (x)
		int static; (x)
	되도록 소문자로 시작한다(java에서는 대소문자를 구분한다)
		int age; (o) 관례상 권장방식
		int Age; (x) 관례상 비권장
	의미없는 문자 사용을 피한다(의미가 명확한 변수명을 사용한다)
		int a; (x)
		int number, age; (o)
	되도록 한글은 사용하지 않는다
		int 나이 = 20; (x) 가능은 하지만 비권장
		int age = 20; (o)

+) 변수 표기법(Naming Convention)
- 스네이크 표기법(Snake Case, 팟홀표기법)
	단어 사이를 _로 구분
	java에서는 상수(final)에서 주로 사용
	
	int user_age = 20;

- 카멜 표기법(Camel Case)
	첫 단어는 소문자, 다음 단어가 있을 때 첫 문자를 대문자로 작성
	
	int userAge =20;
	String userName = "홍길동";

- 파스칼 표기법(Pascal Case)
	모든 단어의 첫 글자를 대문자
	카멜표기법과 유사하지만 첫 글자도 대문자
	java에서는 클래스, 인터페이스 이름에 사용

4. 상수(constant)
	한 번 값이 지정되면 변경할 수 없는 데이터를 의미한다
	final 키워드를 사용하여 상수를 선언한다

1) 상수 선언
	자료형 변수명 = 값;	//변수선언(카멜표기법)
	final 자료형 상수명 = 값; //상수선언(스네이크표기법)
	상수명은 대문자로 작성하고 단어가 바뀔 때 _로 연결한다

2) 상수 사용시 주의사항
	이름 작성 규칙(변수명과 동일)
	초기화 필수 : final 키워드를 사용시 선언과 동시에 무조건 초기화해야한다
	불변성 : 한 번 값이 저장되면 변경할 수 없으므로 값을 유지해야할 때 주로 사용한다

5. 변수를 사용하는 이유(값을 왜 변수에 저장해서 사용할까?)
	반복되는 값을 쉽게 관리하기 위해서(값을 재사용하기 위함)
	값에 의미를 부여하기 위해서(값에 이름을 붙여준다)
	프로그램의 가독성, 유지보수성, 재사용성을 높이기 위해서

6. Java 메모리구조
1) java 프로그램이 메모리를 쓰는 구조
	Java프로그램은 OS 위에서 바로 메모리(램)을 직접 관리하지 않고 
	JVM(Java Virtual Machine)이 중간에서 메모리를 관리한다

	OS : 컴퓨터 전체 자원(메모리, 파일, cpu)을 관리하는 관리자
	JVM : Java 프로그램 전용 관리자
		-> java 코드가 쓰는 메모리 공간을 나눠주고(할당), 정리도 해줌(GC)
	
2) RAM(메모리)
	RAM은 실행중인 프로그램이 당장 쓰는 데이터를 올려두는 작업 공간
	- 프로그램 실행 중에 필요한 데이터(변수 값, 객체, 실행 정보)를 저장
	- 전원이 꺼지면 내용이 사라짐(휘발성)

3) 변수를 선언하면 RAM에 공간이 생긴다는 의미
	int num;	//num이라는 이름으로 정수 하나를 담을 상자(공간)를 만들 준비
	num = 10;	//그 상자에 10을 넣는 것(값 저장=> 값 초기화)
	
4) 주소값(메모리 주소)
	RAM에 공간이 만들어지면 그 공간은 반드시 고유한 위치(주소)를 가진다
	사람은 num이라는 이름표로 찾지만
	컴퓨터는 0x00001 같은 "주소"로 찾아간다

	변수명(num) : 우리가 쓰는 별명
	주소값 : 컴퓨터가 실제로 찾아가는 위치

	num이라는 변수를 찾아 -> 내부적으로 num이 가리키는 주소로 가서 값을 읽어와

5) JVM의 메모리 영역 ★★★★★
	Stack
	Heap
	Method

(1) Stack 영역(스택)
	메소드 실행할 때 생기는 공간
	지역변수(로컬변수), 매개변수(parameter)가 여기에 저장됨
	메소드가 끝나면 자동으로 정리됨(빠름)

	main(String[] args){
		int num = 10;
		int number;
		number = 100;
	}

	main() 시작 -> main용 스택 프레임 생성
	num 저장
	main() 끝 -> 프레임 통째로 삭제


(2) Heap영역(힙)
	new로 만든 객체(Object)가 저장되는 공간
	언제 없어질지 정확한 시점이 정해져있지 않음
	JVM의 GC(Garbage Collector)가 필요 없어진 객체를 정리함

(3) Method영역(메소드/클래스 영역)
	클래스 정보, static 변수, 메소드 코드(바이트코드) 등이 저장
	프로그램 시작 시 클래스 로딩되면서 생성
	전역적으로 공유됨

+) 비유 예시
	RAM(책상) : 실행 중 데이터를 올려두는 공간 전체
	Stack(메모지 영역) : 잠깐 쓰고 버리는 빠른 공간(지역 변수)
	Heap(창고) : 큰 데이터/객체 저장, GC가 정리
	Method(설계도함) : 클래스 구조/메소드/static 정보 저장
	주소값(상자 위치) : 컴퓨터가 정확히 찾아가기 위한 위치 번호
	참조값(주소를 들고 있는 값) : Stack 변수가 들고있는 창고 위치

7. 제어문자(Escape Character / Sequence)
	따옴표 안에서 사용되며 미리 예약된 특수한 기능을 하는 문자
	\(백슬래쉬, 역슬래쉬)를 사용한다

	\n : 줄바꿈
	\t : 일정 간격을 띄워준다(tab)
	\" : 문자열 안에서 큰따옴표를 표현
	\' : 작은 따옴표를 표현
	\\ : 문자열 안에서 역슬래쉬를 표현

8. 출력 메소드
	소괄호 안에 있는 값을 콘솔창에 출력한다
	println()
		전달된 값을 콘솔창에 출력하고 줄바꿈이 된다
	print()
		전달된 값을 콘솔창에 출력하고 줄바꿈이 되지 않는다
	printf()
		형식(서식 format)에 맞는 값을 출력하고 줄바꿈이 되지 않는다

1) 출력메소드의 목적
	프로그램의 실행 결과를 확인 하기 위해(=> 디버깅(오류확인)의 가장 기본적인 수단)
		- 변수 값이 제대로 저장되었는지
		- 연산 결과가 맞는지
		- 조건문/반복문이 정상 동작하는지 확인
	사용자에게 정보를 보여주기 위해
		- 안내 메시지를 출력
		- 처리 결과를 출력
	실행흐름을 파악하기 위해
		- 제어문이 언제 실행되는지 확인
		- 코드의 흐름을 눈으로 확인
	
2) printf() 메소드
	형식(format)에 맞게 값을 출력하는 메소드
	자동 줄바꿈이 되지 않는다 -> 필요하면 \n 직접 작성
	C언어 스타일의 출력 방식

- 형식(서식 Format)
	출력할 값의 모양을 미리 정해두는 것
	
- 기본 형식 지정자 ★★★★★
	형식지정자		의미		예
	%d		정수(int)	10, -10, 0
	%f		실수		3.14
	%s		논리값		true, false
	%c		문자형		'A', 'a'
	%s		문자열		"Java"

- printf()를 사용하는 목적
	숫자 자리 맞추기
	소수점 정확히 제어
	표 형태 출력
	로그 출력시 가독성 향상

- 서식 문자의 옵션
	%[- or 0][n][.m] 서식문자
	- 	왼쪽정렬
	0	비어있는 공간을 0으로 채움(숫자자료형만 가능)
	n	자리수
	.m	실수 소수점 아래 자리수 / 문자열 문자열 자르기

자료형 : 정수(int, long), 실수(double, float), 논리(boolean), 문자형(char), 문자열(String)

9. 형변환(Type Casting)
1) 강제형변환(명시적 형변환)
	개발자가 직접 이 타입으로 바꿔라라고 명령하는 형변환
	(자료형)값

	(double)10; 	=> 10.0
	(int)3.14 	=> 3
	(char)97	=> 'a'
	
	큰범위(큰바이트) -> 작은 범위(작은 바이트)로 바꿀 때 손실 위험
	java는 안전을 위해 자동으로 해주지 않음 -> 강제로만 가능함

ex) int num1 = (int)3L;
	3L long(8byte)
	int(4byte)에 넣으려면 범위가 줄어듦 => (int) 강제 형변환이 필요함

2) 자동형변환(묵시적 형변환)
	java가 안전하다고 판단할 때 자동으로 변환해줌

- 작은타입 -> 큰 타입 저장
	byte -> short -> int -> long -> float -> double

- 연산 시 자동 형변환 규칙
	같은 정수끼리 연산하면 결과는 정수형
		정수 / 정수 -> 정수(소수점 버림)
	정수 + 실수 연산하면 결과는 실수형
		정수 / 실수 => 실수로 자동 변환됨
	문자는 정수로 자동 변환됨
		int number = 'a';
		syso(number) //97

+) 오버플로우/언더플로우
1) 오버플로우(Overflow)
	저장할 값이 자료형이 표현할 수 있는 범위를 넘어서서 값이 깨지는 현상

- 정수형 오버플로우 특징
	정수형(byte, short, int, long)은 범위를 넘어서면 반대쪽으로 돌아감(랩어라운드)이 일어남

	byte 범위 : -128 ~ 127
	
2) 언더플로우(Underflow)
	주로 실수형 발생, 값이 너무 작아서 표현 가능한 최소 양수보다 작아져서 0에 가까워지거나 0이 되는 현상

	실수형 double, float은 0과 가장 작은 양수 사이가 촘촘하지 않음 -> 너무 작으면 저장하지 못하고 0으로 떨어짐

+) float 표현할 수 있는 최소 양수 범위
	float구조(IEEE 754 : Institue of Electrical and Electronics Engineers, 전기/전자/컴퓨터 분야의 국제 표준을 만드는 단체)
	부호(S) : 1비트
	지수(E) : 8비트
	가수(M) : 23비트
	실수 = (-1)^s X 1.m x 2^e

float가 표현 가능한 값 범위 : 가장 작은 정규화된 양수  => 약 1.175 x 10^-38
	이것보다 작은 값은 비정규화 수로 표현되다가 한계를 넘으면 0.0이됨

double의 최소 표현 범위 약 10^-308	10^-50












