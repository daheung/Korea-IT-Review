day18(java 16일차)
복습 -> 컬렉션 프레임워크 -> list -> set -> map -> 총 복습 정리

0. 복습
1) API(Application Programming Interface)
   내부API   
      JDK 설치 시 제공해주는 기본 API
   외부API
      다른 개발자들이 개발한 패키지 및 클래스를 의미
      jar 파일로 배포하며 자바 프로젝트에 build path에 추가하여 사용할 수 있다

2) Stream API
   선언형, 함수형 방식으로 처리하기 위한 API
   여러개의 데이터를 흐름처럼 하나씩 처리하기 위한 도구
   데이터를 저장하지 않는다
   데이터를 하나씩 처리한다
   한 번만 사용할 수 있다

※ 컬렉션을 스트림으로 변환 .stream()
※ 배열/값을 스트림으로 변환 Stream.of()

- 연산 구조
   스트림 생성(소스) -> 중간연산 -> 최종연산

- 중간연산 : 스트림을 변환하고 다시 스트림 반환함(lazy)
   메소드      의미
   filter()   조건에 맞는 요소만 걸러냄
   map()      요소 변환
   mapToInt()   IntStream으로 변환
   flatMap()   스트림 평탄화
   sorted()   정렬
   peek()      중간 확인용(디버깅)
   limit()      개수 제한
   skip()      앞부분 건너뜀
   takeWhile()   조건까지 가져옴(java 9+)

- 최종연산 : 스트림을 소모하고 결과를 만듦
   메소드      의미
   forEach()   순회 처리
   collect()   컬렉션으로 변환
   toList()   List로 변환(java 16+)
   reduce()   누적연산
   count()      개수 세기
   findFirst()   첫요소 반환
   findAny()   아무거나 하나
   anyMatch()   조건 만족 여부
   allMatch()   모두 만족 여부
   noneMatch()   모두 불만족

+) Optional
   null 대신 쓰는 래퍼클래스

Optional<T>
   => 값이 있을 수도/없을 수도 있음을 표현하는 객체

- Optional 만드는 방법
(1) of() -> null 무조건 예외
   Optional<String> o = Optional.of("hi");
   Optional<String> o = Optional.of(null); //예외발생

(2) ofNullable()
   Optional<String> o = Optional.ofNullable(null); //empty로 바뀜

(3) empty()
   Optional<String> o = Optional.empty();
   //명시적으로 비어있음을 표현

3) Object 클래스
   모든 클래스의 최상위 부모 클래스
   
   toString()   참조값을 문자열형태로 반환
   equals()   참조값 비교
         객체를 비교하고 싶다면 비교 기준을 재정의해서 사용할 수 있다
   hashCode()   객체의 메모리 번지를 이용해서 해시코드를 생성하기 때문에 객체마다 다른 정수값을 리턴
         두 객체가 동등함을 비교 시 hashCode()와 equals() 메소드를 같이 사용하므로
         equals() 재정의하면 hashCode()도 변경해야한다

4) Wrapper 클래스
   기본 자료형들의 클래스 타입

- 박싱과 언박싱
   기본 타입의 값을 포장 객체로 만드는 과정 박싱
      클래스타입 참조변수 = 클래스타입.valueOf(일반타입의값);
      클래스타입 참조변수 = 일반타입의값;

   포장 객체에서 기본 타입의 값을 얻어내는 과정 언박싱
      일반타입 변수 = 참조변수.000Value();
      일반타입 변수 = 참조변수;

1. 컬렉션 프레임워크(JCF : Java Collection Framework)
   java.util 패키지에 포함
   많은 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합

1) 인터페이스 분류
   인터페이스 분류      특징         구현클래스
Collection   List      순서를 유지하고 저장      Vector, ArrayList, LinkedList
            중복값 저장 가능
      Set      순서를 유지하지 않고 저장   HashSet, TreeSet
            중복값 저장 불가능

Map            키와 값으로 구성      HashMap, TreeMap, Hashtable
            키는 중복 불가능
            값은 중복 가능

1. List 인터페이스
   데이터의 순서를 보장한다
   중복된 값을 허용한다

1) List 구현 클래스
   Vector : 용량관리, 보안성강호, 처리량 감소 => 지금은 거의 사용되지 않는다
   ArrayList : 배열과 동일하게 인덱스로 데이터를 관리한다
      컬렉션 클래스들 중 실무에서 가장 많이 사용되는 클래스이다
      추가, 삭제는 느리지만 탐색이 상대적으로 빠르다
   LinkedList : 추가 삭제는 빠르지만 탐색이 상대적으로 느리다
   
2) 제네릭(Generic)
   결정되지 않은 타입을 파라미터로 처리하고 실제 사용할 때 구체적인 타입으로 대체시키는 기능
   타입을 미리 정의하지 않고, 나중에 결정

   Class<T> obj = new Class<T>();
   Class<T> obj = new Class<>();   //java 7+

   클래스명 참조변수 = new 생성자();
   클래스명<T> 참조변수 = new 생성자<T>();
   변수를 선언할 때 동일한 타입으로 호출하고 싶다면 생성자 호출시 타입을 명시하지 않고 <>만 붙일수있다
   <>를 다이아몬드 연산자라고 한다
   클래스명<T> 참조변수 = new 생성자<>();

   Iterable<T> 자바의 제네릭 프로그래밍을 지원하는 인터페이스 중 하나이다
   자바 컬렉션 프레임워크에서 많이 사용되며 컬렉션 내부의 요소들을 반복(iterate) 하고자 할 때 사용한다

- 제네릭을 사용하는 이유
   (1) 제네릭을 사용하지 않는다면 필드의 타입별로 클래스를 만들어야한다
   (2) 제네릭 대신 Object 타입을 사용한다면 다운캐스팅을 해야한다
   (3) 제네릭은 타입을 제한할 수 있다(Object는 모든 타입을 다 받을 수 있기 때문이다)

   타입 안정성, 다운캐스팅 제거, 컴파일 에러

+) 추가내용(모르면 패스)
제네릭 제한 <T extends> 상한 제한
   이 타입만 쓰라고 범위를 제한 하는 것

- 기본 문법
   <T extends 부모클래스>
   <T extends 인터페이스>

- PECS 공식
   Producer(읽기) -> extends
      <? extends T>      값생산 -> 읽기용

   Consumer(쓰기) -> super
      <? super T>      값 소비 -> 쓰기용

공용 출력 메소드
   void print(List<?> list)
숫자 처리
   void calc(List<? extends Number> list)

추가
   void add(List<? super Integer> list)

유틸
   static<T> void swap(T[] arr, int i, int j)

- 타입 소거(Type Erasure)
   컴파일 후 제네릭 사라짐

   List<String>
   List<Integer>

   런타임   List

   if(obj instanceof List<String>)   x

3) 배열과 ArrayList의 차이
   배열은 길이에 제한을 두어야할 때 자주 사용하고
   ArrayList는 몇개의 데이터가 들어올 지 알 수 없을 때 사용한다

4) ArrayList 메소드
   int size()      리스트의 요수 개수를 반환
   boolean isEmpty()   리스트가 비어있는지 여부 확인
   boolean contains(Object o) 주어진 객체가 리스트에 포함되어있는지 여부를 확인
   E get(int index)   주어진 인덱스 위치에 있는 요소 반환
   E set(int index, E element) 주어진 인덱스 위치에 있는 요소를 다른 요소로 대체
   boolean add(E e)   리스트에 요소 추가
   boolean remove(Object o) 리스트에서 지정된 객체를 삭제
   int remove(int index)   리스트에서 지정한 인덱스의 요소 삭제
   void clear()      리스트의 모든 요소를 제거하여 비움
   int indexOf(Object o)   주어진 객체의 첫번째 등장하는 인덱스를 반환
   int lastIndexOf(Object o) 주어진 객체의 마지막 등작하는 인덱스를 반환

2. set 인터페이스 : 집합
   데이터의 순서를 보장하지 않는다
   데이터의 중복을 허용하지 않는다

1) 구현 클래스
   HashSet
   set 인터페이스를 구현한 가장 대표적인 클래스
   중복되는 값을 저장하면 무시한다
   인덱스가 존재하지 않아 순서를 보장하지 않으며 ArrayList나 배열처럼 값을 가져오는 것이 불가능하다
   hashCode()가 반환하는 해시코드를 이용하여 데이터를 처리하며 속도가 상대적으로 빠르다
   위의 특징 때문에 값의 존재여부를 파악할 때 사용하기 좋다

2) Iterator : 반복자
   컬렉션에 저장된 데이터를 순회하고 가져오기 위한 인터페이스
   Itreator는 컬렉션의 종류와 상관없이 동일한 방식으로 데이터를 가져올 수 잇기 때문에 컬렉션 프레임워크를
   일관된 방식으로 다룰 수 있게 해준다(타입)
   값을 가져올 때는 커서(cursor)를 이용하여 컬렉션을 순회하며 다음 값을 가리키고 값을 가져올 수 있다
   어떤 자료구조든 Iterator로 변환하면 Itreator 만의 방식으로 순서를 만들고 값을 가져올 수 있다

   Set<E> set1 = new HashSet<>();
   Iterator<E> iter = set1.iterator();

- iterator()
   ArrayList, HashSet 등의 컬렉션 객체를 Iterator 타입으로 변환할 때 사용하는 메소드
- hasNext()
   다음 값의 유무를 검사하여 boolean 타입으로 반환한다
- next()
   다음 값을 가져온다 아무값도 없다면 예외가 발생한다

3. Map
   데이터의 순서를 보장하지 않는다
   데이터를 Key와 Value 한쌍으로 저장하여 key로 데이터에 접근할 수 있다
   그러므로 key는 ArrayList의 index와 비슷한 역할을 하며 중복을 허용하지 않는다

1) 구현 클래스
   HashMap
   hashCode()가 반환하는 해시코드를 이용하며 검색 속도가 상대적으로 빠르다
   이미 저장된 key를 가진 한쌍의 데이터를 넣으면 가장 마지막에 넣은 value로 수정된다
   (value는 중복가능, 수정가능)
   저장되지 않은 key를 가진 한쌍의 데이터를 넣으면 새롭게 추가된다

2) Hash : 데이터를 다루는 기법
   키(key)는 해시함수(Hash Funtion)를 통해 해시(hash)로 변경되며 
   해시는 값(value)과 매칭되어 저장소에 저장된다

- 키(key) : 고유한 값이며 해시함수 input이 된다
   다양한 길이의 값이 될 수 있다
   이 상태로 저장소에 저장되면 다양한 길이만큼의 저장소를 구성해 두어야하기 때문에 해시함수로 값을 바꾸어
   저장되어야 공간의 효율성을 추구할 수 있다

- 해시함수(Hash Function) : 키(key)를 해시(hash)로 바꿔주는 역할을 한다
   다양한 길이를 가지고 있는 키(key)를 일정한 길이를 가지는 해시(hash)로 변경하여 저장소를
   효율적으로 운영할 수 있도록 도와준다
   다만, 서로 다른 키(key)가 같은 해시(hash)가 되는 경우를 해시 충돌이라고 하는데
   해시 충돌을 일으키는 확률을 최대한 줄이는 함수를 만드는 것이 중요하다

- 해시(Hash) : 해시 함수의 결과물
   저장소(bucket, slot)에서 값(value)과 매칭되어 저장된다

- 값(value) : 저장소에 최종적으로 저장되는 값으로 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능하다
   
+) 값 -> 숫자로 바꿔서 저장위치를 정하는 기술 => hash
   "apple" -> 12345
   "banana" -> 54321

hash table : hash 이용한 저장 공간
   [0] null
   [1] cat
   [2] dog
   [3] null
   [4] apple

+)    HashSet      HashMap
저장형태   값만 저장      (key, value)저장
중복   x      key x, value o
용도   중복제거      데이터 매핑
   내부적으로 HashMap사용day18(java 16일차)
복습 -> 컬렉션 프레임워크 -> list -> set -> map -> 총 복습 정리

0. 복습
1) API(Application Programming Interface)
   내부API   
      JDK 설치 시 제공해주는 기본 API
   외부API
      다른 개발자들이 개발한 패키지 및 클래스를 의미
      jar 파일로 배포하며 자바 프로젝트에 build path에 추가하여 사용할 수 있다

2) Stream API
   선언형, 함수형 방식으로 처리하기 위한 API
   여러개의 데이터를 흐름처럼 하나씩 처리하기 위한 도구
   데이터를 저장하지 않는다
   데이터를 하나씩 처리한다
   한 번만 사용할 수 있다

※ 컬렉션을 스트림으로 변환 .stream()
※ 배열/값을 스트림으로 변환 Stream.of()

- 연산 구조
   스트림 생성(소스) -> 중간연산 -> 최종연산

- 중간연산 : 스트림을 변환하고 다시 스트림 반환함(lazy)
   메소드      의미
   filter()   조건에 맞는 요소만 걸러냄
   map()      요소 변환
   mapToInt()   IntStream으로 변환
   flatMap()   스트림 평탄화
   sorted()   정렬
   peek()      중간 확인용(디버깅)
   limit()      개수 제한
   skip()      앞부분 건너뜀
   takeWhile()   조건까지 가져옴(java 9+)

- 최종연산 : 스트림을 소모하고 결과를 만듦
   메소드      의미
   forEach()   순회 처리
   collect()   컬렉션으로 변환
   toList()   List로 변환(java 16+)
   reduce()   누적연산
   count()      개수 세기
   findFirst()   첫요소 반환
   findAny()   아무거나 하나
   anyMatch()   조건 만족 여부
   allMatch()   모두 만족 여부
   noneMatch()   모두 불만족

+) Optional
   null 대신 쓰는 래퍼클래스

Optional<T>
   => 값이 있을 수도/없을 수도 있음을 표현하는 객체

- Optional 만드는 방법
(1) of() -> null 무조건 예외
   Optional<String> o = Optional.of("hi");
   Optional<String> o = Optional.of(null); //예외발생

(2) ofNullable()
   Optional<String> o = Optional.ofNullable(null); //empty로 바뀜

(3) empty()
   Optional<String> o = Optional.empty();
   //명시적으로 비어있음을 표현

3) Object 클래스
   모든 클래스의 최상위 부모 클래스
   
   toString()   참조값을 문자열형태로 반환
   equals()   참조값 비교
         객체를 비교하고 싶다면 비교 기준을 재정의해서 사용할 수 있다
   hashCode()   객체의 메모리 번지를 이용해서 해시코드를 생성하기 때문에 객체마다 다른 정수값을 리턴
         두 객체가 동등함을 비교 시 hashCode()와 equals() 메소드를 같이 사용하므로
         equals() 재정의하면 hashCode()도 변경해야한다

4) Wrapper 클래스
   기본 자료형들의 클래스 타입

- 박싱과 언박싱
   기본 타입의 값을 포장 객체로 만드는 과정 박싱
      클래스타입 참조변수 = 클래스타입.valueOf(일반타입의값);
      클래스타입 참조변수 = 일반타입의값;

   포장 객체에서 기본 타입의 값을 얻어내는 과정 언박싱
      일반타입 변수 = 참조변수.000Value();
      일반타입 변수 = 참조변수;

1. 컬렉션 프레임워크(JCF : Java Collection Framework)
   java.util 패키지에 포함
   많은 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합

1) 인터페이스 분류
   인터페이스 분류      특징         구현클래스
Collection   List      순서를 유지하고 저장      Vector, ArrayList, LinkedList
            중복값 저장 가능
      Set      순서를 유지하지 않고 저장   HashSet, TreeSet
            중복값 저장 불가능

Map            키와 값으로 구성      HashMap, TreeMap, Hashtable
            키는 중복 불가능
            값은 중복 가능

1. List 인터페이스
   데이터의 순서를 보장한다
   중복된 값을 허용한다

1) List 구현 클래스
   Vector : 용량관리, 보안성강호, 처리량 감소 => 지금은 거의 사용되지 않는다
   ArrayList : 배열과 동일하게 인덱스로 데이터를 관리한다
      컬렉션 클래스들 중 실무에서 가장 많이 사용되는 클래스이다
      추가, 삭제는 느리지만 탐색이 상대적으로 빠르다
   LinkedList : 추가 삭제는 빠르지만 탐색이 상대적으로 느리다
   
2) 제네릭(Generic)
   결정되지 않은 타입을 파라미터로 처리하고 실제 사용할 때 구체적인 타입으로 대체시키는 기능
   타입을 미리 정의하지 않고, 나중에 결정

   Class<T> obj = new Class<T>();
   Class<T> obj = new Class<>();   //java 7+

   클래스명 참조변수 = new 생성자();
   클래스명<T> 참조변수 = new 생성자<T>();
   변수를 선언할 때 동일한 타입으로 호출하고 싶다면 생성자 호출시 타입을 명시하지 않고 <>만 붙일수있다
   <>를 다이아몬드 연산자라고 한다
   클래스명<T> 참조변수 = new 생성자<>();

   Iterable<T> 자바의 제네릭 프로그래밍을 지원하는 인터페이스 중 하나이다
   자바 컬렉션 프레임워크에서 많이 사용되며 컬렉션 내부의 요소들을 반복(iterate) 하고자 할 때 사용한다

- 제네릭을 사용하는 이유
   (1) 제네릭을 사용하지 않는다면 필드의 타입별로 클래스를 만들어야한다
   (2) 제네릭 대신 Object 타입을 사용한다면 다운캐스팅을 해야한다
   (3) 제네릭은 타입을 제한할 수 있다(Object는 모든 타입을 다 받을 수 있기 때문이다)

   타입 안정성, 다운캐스팅 제거, 컴파일 에러

+) 추가내용(모르면 패스)
제네릭 제한 <T extends> 상한 제한
   이 타입만 쓰라고 범위를 제한 하는 것

- 기본 문법
   <T extends 부모클래스>
   <T extends 인터페이스>

- PECS 공식
   Producer(읽기) -> extends
      <? extends T>      값생산 -> 읽기용

   Consumer(쓰기) -> super
      <? super T>      값 소비 -> 쓰기용

공용 출력 메소드
   void print(List<?> list)
숫자 처리
   void calc(List<? extends Number> list)

추가
   void add(List<? super Integer> list)

유틸
   static<T> void swap(T[] arr, int i, int j)

- 타입 소거(Type Erasure)
   컴파일 후 제네릭 사라짐

   List<String>
   List<Integer>

   런타임   List

   if(obj instanceof List<String>)   x

3) 배열과 ArrayList의 차이
   배열은 길이에 제한을 두어야할 때 자주 사용하고
   ArrayList는 몇개의 데이터가 들어올 지 알 수 없을 때 사용한다

4) ArrayList 메소드
   int size()      리스트의 요수 개수를 반환
   boolean isEmpty()   리스트가 비어있는지 여부 확인
   boolean contains(Object o) 주어진 객체가 리스트에 포함되어있는지 여부를 확인
   E get(int index)   주어진 인덱스 위치에 있는 요소 반환
   E set(int index, E element) 주어진 인덱스 위치에 있는 요소를 다른 요소로 대체
   boolean add(E e)   리스트에 요소 추가
   boolean remove(Object o) 리스트에서 지정된 객체를 삭제
   int remove(int index)   리스트에서 지정한 인덱스의 요소 삭제
   void clear()      리스트의 모든 요소를 제거하여 비움
   int indexOf(Object o)   주어진 객체의 첫번째 등장하는 인덱스를 반환
   int lastIndexOf(Object o) 주어진 객체의 마지막 등작하는 인덱스를 반환

2. set 인터페이스 : 집합
   데이터의 순서를 보장하지 않는다
   데이터의 중복을 허용하지 않는다

1) 구현 클래스
   HashSet
   set 인터페이스를 구현한 가장 대표적인 클래스
   중복되는 값을 저장하면 무시한다
   인덱스가 존재하지 않아 순서를 보장하지 않으며 ArrayList나 배열처럼 값을 가져오는 것이 불가능하다
   hashCode()가 반환하는 해시코드를 이용하여 데이터를 처리하며 속도가 상대적으로 빠르다
   위의 특징 때문에 값의 존재여부를 파악할 때 사용하기 좋다

2) Iterator : 반복자
   컬렉션에 저장된 데이터를 순회하고 가져오기 위한 인터페이스
   Itreator는 컬렉션의 종류와 상관없이 동일한 방식으로 데이터를 가져올 수 잇기 때문에 컬렉션 프레임워크를
   일관된 방식으로 다룰 수 있게 해준다(타입)
   값을 가져올 때는 커서(cursor)를 이용하여 컬렉션을 순회하며 다음 값을 가리키고 값을 가져올 수 있다
   어떤 자료구조든 Iterator로 변환하면 Itreator 만의 방식으로 순서를 만들고 값을 가져올 수 있다

   Set<E> set1 = new HashSet<>();
   Iterator<E> iter = set1.iterator();

- iterator()
   ArrayList, HashSet 등의 컬렉션 객체를 Iterator 타입으로 변환할 때 사용하는 메소드
- hasNext()
   다음 값의 유무를 검사하여 boolean 타입으로 반환한다
- next()
   다음 값을 가져온다 아무값도 없다면 예외가 발생한다

3. Map
   데이터의 순서를 보장하지 않는다
   데이터를 Key와 Value 한쌍으로 저장하여 key로 데이터에 접근할 수 있다
   그러므로 key는 ArrayList의 index와 비슷한 역할을 하며 중복을 허용하지 않는다

1) 구현 클래스
   HashMap
   hashCode()가 반환하는 해시코드를 이용하며 검색 속도가 상대적으로 빠르다
   이미 저장된 key를 가진 한쌍의 데이터를 넣으면 가장 마지막에 넣은 value로 수정된다
   (value는 중복가능, 수정가능)
   저장되지 않은 key를 가진 한쌍의 데이터를 넣으면 새롭게 추가된다

2) Hash : 데이터를 다루는 기법
   키(key)는 해시함수(Hash Funtion)를 통해 해시(hash)로 변경되며 
   해시는 값(value)과 매칭되어 저장소에 저장된다

- 키(key) : 고유한 값이며 해시함수 input이 된다
   다양한 길이의 값이 될 수 있다
   이 상태로 저장소에 저장되면 다양한 길이만큼의 저장소를 구성해 두어야하기 때문에 해시함수로 값을 바꾸어
   저장되어야 공간의 효율성을 추구할 수 있다

- 해시함수(Hash Function) : 키(key)를 해시(hash)로 바꿔주는 역할을 한다
   다양한 길이를 가지고 있는 키(key)를 일정한 길이를 가지는 해시(hash)로 변경하여 저장소를
   효율적으로 운영할 수 있도록 도와준다
   다만, 서로 다른 키(key)가 같은 해시(hash)가 되는 경우를 해시 충돌이라고 하는데
   해시 충돌을 일으키는 확률을 최대한 줄이는 함수를 만드는 것이 중요하다

- 해시(Hash) : 해시 함수의 결과물
   저장소(bucket, slot)에서 값(value)과 매칭되어 저장된다

- 값(value) : 저장소에 최종적으로 저장되는 값으로 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능하다
   
+) 값 -> 숫자로 바꿔서 저장위치를 정하는 기술 => hash
   "apple" -> 12345
   "banana" -> 54321

hash table : hash 이용한 저장 공간
   [0] null
   [1] cat
   [2] dog
   [3] null
   [4] apple

+)    HashSet      HashMap
저장형태   값만 저장      (key, value)저장
중복   x      key x, value o
용도   중복제거      데이터 매핑
   내부적으로 HashMap사용

3) Entry
   java 컬렉션 프레임워크에서 키-값 쌍을 표현하는 인터페이스
   주로 Map 인터페이스와 함께 사용된다

   Entry<K, V>는 Map 인터페이스 내부에 정의된 중첩 인터페이스 Map.Entry<K, V>
   한개의 키와 그에 대응하는 값을 저장하는 구조를 제공한다
   Map의 모든 요소를 순회하거나 키와 값을 개별적으로 처리할 때 사용한다

- Map.Entry의 메소드
   k getKey()      엔트리의 키를 반환
   v getValue()      엔트리의 값을 반환
   v setValue(V value)   엔트리의 값을 주어진값으로 설정하고 이전값을 반환
   boolean equals(Object o)   다른 객체와 이 엔트리를 비교
   int hashCode()      엔트리의 해시코드를 반환
   entrySet()      Set<Map.Entry<K, V>> 형태로 MAP의 모든 키와 값 쌍을 순회

- Map
   |_ Entry<K, V>   Entry는 Map안에 포함된 인터페이스

- Map.Entry의 용도
   Map 전체 순회할 때
   key와 value를 동시에 사용할 때
   Map 데이터를 가공할 때

   for(Map.Entry<K, V> entry : map.entrySet())
