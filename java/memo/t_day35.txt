day35(java 21일차)
쓰레드 -> 파일 입출력

260220 한컴타자연습
한타 : 푸른 뱀, AI 창작 동화(2025)
영타 : Magdalen Walks


1. 쓰레드 알기 전 사전 지식
1) 컴퓨터 3계층
   응용 소프트웨어(Application Software) : 사용자가 실제로 사용하는 프로그램
   시스템 소프트웨어(Operating System)
       : 하드웨어를 직접 제어하고 응용 소프트웨어가 하드웨어를 사용할 수 있도록 중간역할을 한다
      Windows, macOS, Linux 등
   하드웨어(Hardware) : 물리적 장치 전체 의미(CPU, RAM, HDD/SSD, 키보드, 모니터, ..)

2) 시스템 자원(System Resource)
   프로그램이 실행되기 위해서는 반드시 OS로부터 자원을 할당받아야한다
   
- 하드웨어 자원
   CPU, RAM(주기억장치), HDD/SSD(보조기억장치), 입출력장치

- 소프트웨어 자원
   파일(File), 소켓(Socket), Signal, 기타 소프트웨어

3) 프로세스(Process)
   OS로부터 시스템 자원을 할당받는 작업의 단위
   프로그램을 실행하면 OS가 RAM에 올리고, CPU 사용권, 파일 핸들 등 시스템 자원을 할당한다
   실행중인 상태를 프로세스라고 한다

   프로그램(HDD에 저장된 .exe, .class 파일)
   ↓ 실행
   프로세스(RAM에 올라간 실행단위, OS가 자원할당)

4) JAVA와 JVM의 관계
   일반 c/c++ 프로그램은 OS가 직접 실행한다
   OS -> 프로그램 실행 -> 시스템 자원 직접 할당

   OS -> JVM 실행 -> JVM이 Java 프로그램 실행 -> 자원은 JVM을 통해 간접 할당

- JVM(Java Virtual Machine)
   java 바이트코드를 해석해서 실행하는 가상 머신
   JVM 자체가 하나의 프로세스로 OS에서 실행되고 JAVA프로그램은 그 JVM 위에서 동작한다
   Java는 OS에 독립적이다
      
   Write Once, Run Anywhere

5) 쓰레드와 JVM 관리
   프로세스 내에서 실제 작업을 수행하는 실행 흐름의 단위
   하나의 프로세스 안에 여러 쓰레드가 존재할 수 있고 쓰레드들은 프로세스의 메모리자원(Heap, Method Area)을 공유함
   
프로세스(jvm)
   |- Thread-1 ( main 메소드 실행 ) 
   |- Thread-2 ( 추가작업 )
   |- Thread-3 ( 추가작업 )
   |_ 공유 메모리 : Heap, Method Area
     각 쓰레드 개별 : Stack, PC Register

[하드웨어]  cpu, RAM, I/O
    직접 제어
[운영체제]  Windows
    시스템 자원 할당
[JVM]   하나의 프로세스
    바이트코드 해석 및 실행, 쓰레드 관리
[Java Application] main(), Thread, 객체들..

2. 쓰레드(Thread)
1) 싱글 쓰레드
   하나의 쓰레드가 작업을 마치면 프로그램이 종료한다
   쓰레드를 하나만 가지고 있기 때문에 작업을 순차적으로 처리하므로 상대적으로 비효율적이다
   쓰레드는 자원을 사용하는데 싱글 쓰레드는 혼자서 자원하므로 동기화를 걱정할 필요가 없다
   따라서 안정성이 높고 설계가 쉽다

2) 멀티 쓰레드
   메인쓰레드가 작업을 마치더라도 다른 쓰레드의 작업이 모두 끝나야 프로그램이 종료된다
   하나의 프로세스에서 여러 작업을 동시에 처리하는 것처럼 느껴지지만 사실은 각각의 쓰레드를
   매우 빠른 속도로 번갈아가며 실행시켜서 조금씩 처리한다
   쓰레드간 공유하는 자원이 있다면 충돌이 생겨 문제가 생길수있으며 이런 문제를 동기화(Synchronized)를 통해 해결한다
   안정성이 떨어지고 설계가 굉장히 어렵다
   ※ 동시에 실행하는 것처럼 보이지만 실제로는 매우 빠르게 번갈아 가면서 실행됨(컨텍스트 스위칭)
   단, 멀티코어 CPU에서는 실제 병렬 실행도 가능 

3. 멀티쓰레드
1) 멀티쓰레드 구현 방법
   Thread 클래스 상속
   Runnable 인터페이스 구현

   -> run() 메소드에 쓰레드가 처리할 작업을 재정의한다(오버라이딩)
   -> start() 메소드로 쓰레드를 실행시킨다

+) Thread.currentThread().getName()
   현재 실행중인 쓰레드의 이름을 반환하는 기능
   어떤 쓰레드가 작업을 수행중인지 확인할 수 있다

Thread.currentThread()
   Thread 객체의 정적 메소드, 호출되는 시점의 현재 쓰레드를 참조
   현재 실행중인 쓰레드를 반환한다

getName()
   Thread 객체의 인스턴스 메소드, 해당 쓰레드의 이름을 반환

쓰레드 이름
   디버깅할 때 어떤 쓰레드가 작업을 하는지 조사할 목적으로 주로 사용된다
   현재 코드를 어떤 쓰레드가 실행하는지 확인하려면 currentThread() 정적 메소드로 쓰레드 객체의 참조를 얻은 다음
   getName() 메소드로 이름을 출력하면 된다

   메인쓰레드 : main
   작업쓰레드 : Thread-n의 이름을 가진다
      작업 쓰레드의 이름을 다른 이름으로 설정하고 싶다면 Thread클래스의 setName()메소드를 사용하면된다
      Thread.setName("쓰레드 이름");

2) 쓰레드 스케줄링
   어떤 쓰레드를 언제 실행할 지 결정하는 것
   java에서는 쓰레드 실행 순서를 우리가 직접 정하지 않는다
   JVM이 운영체제(OS)의 스케줄러에게 위임하고, OS가 CPU 사용 순서를 결정한다

   start()를 호출해도 어떤 쓰레드가 먼저 실행될지는 보장되지 않는다
   실행순서는 매번 달라질 수 있다
   
3) 멀티쓰레드 관련 메소드
(1) run()
   @Override
   public void run(){
      //쓰레드가 수행할 작업
   }

   쓰레드가 실제로 실행하는 코드 영역
   직접 호출하면 멀티 쓰레드가 아님
   단순한 메소드 호출일 뿐이다

   run() 실행내용
   start() 진짜 쓰레드를 생성

(2) start()
   쓰레드객체.start()

   새로운 쓰레드를 생성
   JVM이 스케줄링 대상에 등록
   내부적으로 run() 호출

- 실행흐름
   start()
   ↓
   새로운 쓰레드 생성
   ↓
   JVM이 run() 실행

(3) sleep(long millis)
   Thread.sleep(500); 0.5초 정지
   현재 실행중인 쓰레드를 지정시간동안 일시 정지
   CPU를 다른 쓰레드에게 양보
   
   정적메소드
   반드시 try-catch 필요
   InterruptedException 발생 가능

   try{
      Thread.sleep(500);
   }catch(InterruptedException e){
      e.printStackTrace();
   }
   
   sleep()은 현재 쓰레드만 멈추고 다른 쓰레드는 계속 실행됨

(4) join(), join(long millis)
   다른 쓰레드의 작업이 끝날때까지 기다림

   t1.join();
   현재 쓰레드가 t1의 작업이 끝날때까지 기다림

- 동작흐름
   t1.start();
   t1.join();
   syso("끝");

   t1 실행 -> t1 종료 -> 끝
   
   t1.join(2000);
   최대 2초동안만 기다림
   2초지나면 현재 쓰레드가 다시 실행

(5) wait()
   동기화된 영역에서만 사용가능
   쓰레드의 lock을 회수하여 다른 쓰레드에게 제어권을 넘겨주고 대기한다(대기중에는 lock을 얻을 수 없다)

(6) notify()
   동기화된 영역에서만 사용 가능
   대기 중인 쓰레드 중 하나를 깨운다
   실행 가능한 상태로 바뀌는 것이지 lock을 넘겨주는 것이 아니다

4) 쓰레드 동작과정
   Thread 클래스 상속 또는 Runnable 인터페이스를 통해 run()메소드를 구현
   쓰레드 객체 생성
   start() 메소드를 호출
   쓰레드 실행
   쓰레드 종료

5) 쓰레드 상태
   쓰레드는 생성된 후부터 종료될때까지 여러 상태를 가질 수 있다
   
   NEW      쓰레드가 생성되고 아직 start()가 호출되지 않은 상태
   RUNNABLE   실행 중 또는 실행 가능한 상태
   BLOCKED      동기화 블록에 의해서 일시 정지된 상태(LOCK이 풀릴 때까지 기다리는 상태)
   WAITING,   쓰레드의 작업이 종료되지 않았지만 실행가능하지 않음(UNRUNNABLE) 일시정지 상태,
   TIME_WAITING   일시정지 시간이 지정된 경우를 의미함
   TERMINATED   쓰레드의 작업이 종료된 상태

   객체생성 -> start() 호출 -> 실행 ->            실행대기       -> 실행 -> 실행완료
   NEW   -> RUNNABLE   -> RUNNING -> WIATING/BOLCKED/TIME_WAITING -> RUNNING -> TERMINATED

   쓰레드에서 처리할 로직을 run() 메소드에서 구현하고 Thread 클래스의 start() 메소드를 이용해 실행
   -> 실행 대기 상태로 들어감(JVM의 스케줄링에 의해 실행할 수 있는 상태)
   -> 자바 프로그램은 JVM에 의해 실행되는 쓰레드가 결정되며 이것을 스케줄링이라고 한다

+) 쓰레드 실행 흐름
   run() 구현
   start()
   RUNNABLE 상태
   JVM + OS 스케줄링
   실행 결정

+) 멀티쓰레드의 최대 문제 : 교착상태(DeadLock)
   서로 상대가 가진 lock을 기다리느라 영원히 멈춰있는 상태
   멀티쓰레드 프로그래밍이나 멀티쓰레드 환경에서 발생하는 문제
   여러 쓰레드가 서로 자원을 점유한 상태에서 다른 쓰레드가 점유하고 있는 자원을 기다리며 무한 대기 상태에 빠지는
   비정상적인 상황을 의미함

ex) A쓰레드와 B쓰레드가 있을때
   A쓰레드 -> 자원1 lock 획득 -> 자원2 기다림
   B쓰레드 -> 자원2 lock 획득 -> 자원1 기다림

   둘 다 무한 대기
   프로그램 멈춤

- 해결 방법
   한 쓰레드를 강제 종료
   lock 순서를 통일
   timeout 사용
   전체 깨우기(notifyAll)

- 교착상태 해결 전략(시험빈출)
   예방   교착상태가 발생하지 않도록 4가지 조건 중 최소 하나를 제거
   회피   교착상태가 발생할 수 있는 자원요청을 사전에 파악하여 허용여부 결정
      -> 대표 알고리즘 : 은행가 알고리즘(Banker's Algorithm)
   탐지   교착상태 발생을 허용하고 발생시 탐지 후 처리
   회복   교착상태 탐지 후 특정 프로세스 종료 또는 자원 회수로 해결

- 교착상태가 발생하는 4가지 조건(시험빈출)
   - 상호배제 : 자원이 한번에 하나의 쓰레드만 사용할 수 있다
   - 점유대기 : 한 쓰레드가 자원을 점유한 상태에서 추가로 다른 자원을 요청하며 대기한다
   - 비선점 : 쓰레드가 점유한 자원을 빼앗을 수 없다
   - 순환대기 : 두 개 이상의 쓰레드가 자원을 순환적으로 대기한다

- 보안관점
서비스 거부 공격(DoS)의 원인
(1) 자원고갈공격(Resource Exhaustion)
   공격자가 의도적으로 특정 API를 반복 호출 -> 락 경합 증가 -> Deadlock 유도 -> 서버 멈춤
   DB Connection Pool, 파일 핸들, 세션 저장소에서 특히 위험

(2) 분산 시스템에서 교착
   서비스 A -> 서비스 B 호출
   B -> 다시 A 호출
   상호 트랜잭션 락 발생 가능

(3) DB Deadlock
   DB 레벨에서 교착
   금융/결제 시스템에서 흔하게 발생함

6) 동기화(Syncronization)
   A 쓰레드와 B 쓰레드가 작업을 진행할 때 A가 사용중인 자원을 B가 사용하여 변경한다면 A의 작업의도와 다르게
   결과가 나타날 수 있다
   이러한 것을 방지하기 위해 하나의 자원을 여러 쓰레드가 동시에 접근하지 못하게 막는 것을 동기화 라고한다

- 동기화 영역 만들기
   syncronized(객체명) { ... } : 동기화 블록
      일부 소스코드만 동기화를 걸어준다
      쓰레드는 지정된 객체의 lock을 얻어내며 해당 객체의 lock을 가진 쓰레드만 동기화 블록에 접근이 가능하다
   
   syncronized 리턴타입 메소드명(){ ... } : 동기화 메소드
      해당 메소드 전체에 동기화를 걸어준다

7) Lock 
   쓰레드가 공유되는 자원을 사용할 때 생기는 문제를 동기화로 해결한다
   이 때 하나의 자원에 하나의 쓰레드만 접근하기 위해 사용되는 개념이 lock이다
   자바의 모든 객체는 하나의 lock을 가지고 있다
   동기화된 영역을 쓰레드가 사용하기 위해서는 lock을 획득해야만 하며,
   동기화 영역을 벗어나면 lock을 반납하고 다른 쓰레드가 lock을 가져와 자원을 사용한다

- 동작흐름
   쓰레드가 synchronized 영역 진입 시도
   lock이 비어있으면 획득
   다른 쓰레드는 BLOCKED 상태
   영역 빠져 나가면 lock 반남

- 쓰레드 제어 메소드 비교
   메소드      특징      lock 유지여부
   sleep()      일정시간멈춤   유지
   join()      특정 쓰레드 기다림   유지
   wait()      대기      반납
   notify()   대기 쓰레드 깨움   유지

+) Race Condition(경쟁 상태)
   여러 쓰레드가 공유자원에 동시에 접근해서 실행 순서에 따라 결과가 달라지는 현상

- 발생할 수 있는 조건 3가지(조건3가지가 동시에 만족될 때 발생)
   공유 자원 존재
   두 개 이상 쓰레드가 접근
   적어도 하나는 수정 작업

- 발생 영역
   은행시스템    계좌 잔액 차감
   재고시스템      상품 수량 감소
   게임서버      점수 계산
   웹서버      방문자 수 카운트
   로그파일      동시 기록

   Thread A----
          |-> 공유자원 -> 충돌
   Thread B----

- 보안
Race Condition Vulnerability(경쟁상태 취약점)
   공격자가 두 요청을 거의 동시에 보내거나 시스템의 타이밍 차이를 이용하여 보호 로직을 우회하는 방식

- 은행/결제 시스템 이중 출금
   공격자가 동시에 두 요청을 보내면
   잔액 1000원
   A요청 확인 -> 가능
   B요청 확인 -> 가능
   A차감
   B차감
   마이너스 잔액
   핀테크 서비스에서 발생한 사례 존재함
- 쿠폰 이벤트 남용
- 인증/토큰 재사용

8) 쓰레드 종료 방법
방법1) interrupt() + 예외처리
   안전하게 종료 가능
   catch(InterruptedException e){
      return; //종료
   }

방법2) System.exit(0)
   프로그램 전체 종료
   모든 쓰레드 종료
   실무에서 거의 사용하지 않음

방법3) interrupted() 확인
   sleep 사용하지 않을 때
   while(true){
      if(Thread.interrupted()){
         break;
      }
   }

+) interrupted()
   t.interrupted()
   이 쓰레드를 멈춰야할 수 있으니 확인해라는 신호를 보내는 것
   강제종료가 아니다

- sleep() / wait() / join() 중 일 때
   쓰레드를 대기 상태로 만듦
   
   sleep()
   ↓
   interrupt
   ↓
   InterruptedException 발생
   ↓
   catch문으로 이동
   단, catch문에서 종료 코드를 작성하지 않으면 계속 실행됨

- 대기상태가 아닐 때
   while(true){
      //무한루프
   }

   interrupt()는 예외를 발생시키지 않음
   내부에 interrupt 플래그만 true로 변경됨

   Thread.interrupt()   //확인 후 false로 초기화
   Thread.currentThread().isInterrupted()    //상태 유지

4. 파일 입출력
   파일은 외부데이터다
   자바 기준으로 읽기/쓰기를 구분한다
   DB와 파일은 저장방식이 다르다

1) 외부 데이터와 내부데이터
- 외부 데이터(External Data)
   프로그램이 실행되는 환경에서 제공하는 데이터를 의미
   파일 시스템, 데이터베이스, 네트워크 등의 외부 리소스에서 가져올 수 있다
   
- 내부 데이터(Internal Data)
   프로그램 자체에서 생성하거나 사용하는 데이터를 의미
   프로그램 실행중에 메모리에 존재하며 변수, 객체, 배열 등의 형태로 사용된다

      위치      예시
내부데이터      jvm메모리      변수, 배열
외부데이터      프로그램 외부   파일, DB

2) 스트림(Stream)
   파일과 자바 사이에는 직접 연결이 없다
   반드시 Stream이라는 통로를 통해 이동한다
   기준은 항상 자바

- 스트림 : 데이터를 주고받는 통로, 데이터는 바이트 형태로 전송된다
- 버퍼(buffer) : 데이터를 전송할 때 데이터를 임시로 저장하는 공간(임시 저장공간)
- 스트림과 버퍼
   데이터를 바이트 단위로 바로 전송하지 않고 버퍼라는 임시 저장공간에 저장을 하여
   일정 데이터가 쌓였을 때 한 번에 전송하면 전송속도가 빠르다

3) File 클래스
   파일을 자바의 객체로 다룰 수 있게 해주는 클래스
   외부에 파일을 만들거나 외부 파일을 가져올 때 그 파일을 File 타입의 객체로 만들어서 사용한다

4) 스트림의 종류
   기본 스트림 : 실제 데이터를 주고받는 스트림
   보조(필터) 스트림 : 기본 스트림을 보조하여 기능을 향상시킨다

- 기본 스트림
   InputStream   자바로 들어오는 것, 데이터를 바이트로 전송한다
   OuputStream   자바에서 나가는 것, 데이터를 바이트로 전송한다
   Writer/Reader   데이터를 2바이트씩(문자단위) 전송한다

- 보조스트림
   Buffered
   BufferedOutputStream, BufferedWriter 등..
   데이터를 버퍼로 처리한다

5) 파일 입출력
   Writer(출력)
      BufferedWriter : 버퍼를 사용한 출력 클래스
      FileWriter : 전달한 경로의 파일을 출력하기 위한 목적으로 열어준다. 전달한 경로에 파일이 없다면
         새롭게 만든 후 열어준다
      File : 전달한 경로에 있는 파일의 정보를 담는다

   Reader(입력)
      BufferedReader : 버퍼를 사용한 입력 클래스
      FileReader : 전달한 경로의 파일을 입력하기 위한 목적으로 열어준다. 전달한 경로에 파일이 없다면
         FileNotFoundException 예외가 발생한다
      File : 전달한 경로에 있는 파일의 정보를 담는다