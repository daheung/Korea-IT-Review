day06(java 4일차)
복습 -> 연산자2 -> 제어문1

260107 한컴타자연습
한타 : 독립운동
영타 : Impression Du Matin

0. 복습
1) 형변환
기본 자료형끼리의 형변환
- 강제형변환(명시적 캐스팅)
	(자료형)값
	큰 범위를 작은 범위에 넣을 때(정보 손실 가능)
	의도적으로 타입 맞출 때 사용
	
- 자동형변환(묵시적 캐스팅)
	작은 byte -> 큰 byte로 갈 때
	연산규칙	정수 + 정수 => 정수	정수 + 실수 => 실수
	문자(char)는 정수(유니코드 값)로 연산 시
	'A' + 1 -> 66

- 다른 기본 자료형 -> String
	+ ""
	StringBuilder 고려 가능(참고로만, 코드 작성시 지금 사용하지 않는다)

- String -> 다른 기본 자료형
	int 	Integer.parseInt("123");
	long	Long.parseLong("123");
	double	Double.parseDouble("3.14");
	float	Float.parseFloat("3.14");
	boolean	Boolean.parseBoolean("true");
		true (대소문자 무시)만 true, 나머지는 false
	char 	"문자열".charAt(index);
		"문자열".charAt(0);	=> 문

2) 입력 메소드
- Scanner 사용준비
	import java.util.Scanner;
	Scanner sc = new Scanner(System.in);

- 입력메소드
	next()		입력받은 값을 String 타입으로 반환
			띄어쓰기, 엔터로 구분하고 분리
	nextLine()	입력받은 값을 String 타입으로 반환
			띄어쓰기를 포함한 한 줄 전체를 입력받음
			엔터 이전까지의 값만 가져온다
			엔터를 임시저장공간에서 소모한다
	nextInt()	입력받은 값을 int 타입으로 반환
	nextDouble()	입력받은 값을 double 타입으로 반환

3) 연산자
	최우선 연산자	() 괄호	. 참조	[]	메소드 호출()
	단항 연산자	++ --	+ -(부호)	!(논리부정)	(type) 형변환
	산술 연산자	* / % + - 
	쉬프트 연산자	<< (왼쪽이동)	>> (오른쪽으로 이동, 부호 유지) >>> (오른쪽으로 이동, 0으로 채움)
	관계 연산자	> < >= <= == !=
	논리 연산자	&& (AND)	|| (OR)		!(NOT)
	삼항 연산자	조건식? 참일때의 값 : 거짓일 때의 값; 
	대입 연산자	=
			+= -= *= /= %=

1. 삼항연산자(?:)
	조건식? 참일때의 값 : 거짓일 때의 값;
	
	삼항연산자의 결과는 값이다
	값 => 변수에 저장 가능, 출력 가능
	
2. 비트 연산
1) 비트(bit)와 바이트(byte)
- 비트(bit)
	정보의 최소 단위
	0과 1
	ex) 스위치 : 꺼짐(0) / 켜짐(1)
	    참/거짓, 예/아니오 판단

- 바이트(byte)
	8bit = 1byte
	컴퓨터는 데이터를 보통 바이트 단위로 다룸(문자, 파일, 메모리 주소 등)
	문자 'A'	=> 65
	2진수 01000001

+) 비트 단위로 연산하는 이유
	컴퓨터(cpu)는 내부적으로 2진수 비트로 처리
	비트 연산은 하드웨어 수준에서 매우 빠르게 수행됨
	- 마스크(mask)로 특정 비트만 뽑기
	- 플래그(flag) 관리
	- 암호/압축/그래픽/네트워크 처리
	- 성능 최적화

2) 비트연산자(AND, OR, XOR, NOT)
	비트연산자는 각 비트 자리끼리 계산한다

(1) AND & : 둘 다 1이면 1
	1 & 1 = 1, 그 외는 0

	10과 11을 AND 연산
	
	10을 2진수로 변환 => 00001010
	11을 2진수로 변환 => 00001011
			-----------
			  00001010	=> 10


(2) OR | : 하나라도 1이면 1
	0 | 0 = 0, 그 외는 1

	10	=> 1010
	11	=> 1011
		 -------
		   1011	=> 11


(3) XOR ^ : 같으면 0, 다르면 1
	0 ^ 0 = 0
	0 ^ 1 = 1
	1 ^ 0 = 1
	1 ^ 1 = 0

	1010
	1011
	-----
	0001	=> 1

	a ^ a = 0
	a ^ 0 = a

(4) NOT ~ : 비트 반전
	0 -> 1
	1 -> 0

	~1010
	 0101 => 5

	컴퓨터는 정수를 보통 2의 보수로 표현하기 때문
	
- 2의 보수 체계
	-n = (~n) + 1
	~n = -n - 1 = -(n+1)
	~n = -(n + 1)


NOT 반전
	NOT(~)	: 0 -> 1, 1 -> 0

	10	00001010	
		~~~~~~~~
		11110101

	0101은 4비트 계산일 때만 5
	컴퓨터는 8비트, 16비트, 32비트로 계산한다

		11101010
		00001010
	     +         1
		-11

+) 1의 보수 : 이진수의 모든 비트를 반전시켜서 구한다(1 -> 0, 0 -> 1)
	
	양수 5 => 0101
	1의보수 => 1010

	음수 표현 : -x => x의 1의 보수
	0000	양수 0
	1111	음수 -0

+) 2의 보수 : 1의 보수 + 1로 계산된다
	
	양수 5 => 0101
	1의보수 => 1010
	2의보수 => 1010 + 1 => 1011

	음수표현 : -x => x의 2의 보수
	0은 유일한 형태로 존재 0000

3) 쉬프트 연산자
	<< >> >>>

		[0][0][0][0][1][0][1][0]

좌쉬프트	A << B : A의 비트를 왼쪽으로 B만큼 이동시킨다
		오른쪽에 생기는 빈칸은 0으로 채워진다
		지정된 비트수를 넘어가면 잘린다

		10 =>[0][0][0][0][1][0][1][0]
		20 =>[0][0][0][1][0][1][0][0]
	
	ex) 5 << 1	=> 10
	    5 << 2 	=> 20		0101	<< 00010100

우쉬프트 A >> B : A의 비트를 오른쪽으로 B만큼 이동시킨다
		왼쪽에 생기는 빈칸은 부호비트에 따라 달라진다(양수면 0으로 채워지고 음수면 1로 채워진다)
		이동 중 잘린 비트는 삭제된다
	
		10 => 		[0][0][0][0][1][0][1][0]
		10 >> 1 => 	[0][0][0][0][0][1][0][1] => 5

+) 암호화와 복호화
	데이터를 안전하게 전송하거나 저장하기 위한 과정

1) 암호화
	원본 데이터를 변형하여 외부에서 알아보기 어려운 형태로 만든 과정
	특정 알고리즘과 키를 사용하여 원본 데이터를 암호화
	결과로 나온 암호문은 원본 데이터와는 다른 형태의 데이터이며, 키를 알지 못하는 한 해독하기가 어렵다

2) 복호화
	암호화 된 데이터를 다시 원래의 형태로 되돌리는 과정
	암호화할 때 사용한 알고리즘과 동일한 키를 사용하여 암호화된 데이터를 해독
	복호화된 결과는 원본 데이터로 복원

+) 대칭키 / 비대칭키
1) 대칭키
	대칭키 암호화는 하나의 키를 사용하여 데이터를 암호화하고 복호화 하는 방법
	속도가 빠르고 효율적이며 대부분의 일상적인 데이터 보호 작업에 사용
	
	A라는 문자를 암호화 : 보내는 사람과 받는 사람 모두 동일한 키를 가지고 있어야한다

2) 비대칭키
	두 개의 서로 다른 키(공개키와 개인키)를 사용하여 데이터를 암호화하고 복호화 하는 방법
	공개키는 누구나 알 수 있는 키이며 개인키는 소유자만 알고있어야하는 비밀키
	데이터를 공개키로 암호화하면 개인키로만 복호화 할 수 있고
	개인키로 암호화된 데이터는 공개키로만 복호화 할 수 있다
	데이터의 안전한 전송과 디지털 서명에 사용

3. 제어문
	프로그램의 흐름을 제어한다
	기본방향 : 위에서 아래로, 왼쪽에서 오른쪽으로

	조건문	조건식의 결과에 따라서 실행 흐름을 결정한다
		if문(if, if~else, if~else if~else) , switch문
	반복문	특정 조건을 만족할 때까지 실행 코드를 반복 실행한다
		for문, while문, do~while문
	기타제어문	흐름을 건너뛰거나 즉시 종료한다
		break문, continue문

4. 조건문 - if문
1) if문
	if : 만약 ~라면

	조건식의 결과가 true라면 중괄호 영역 안으로 들어가서 문장을 실행하고 다음 코드를 순차적으로 실행한다
	조건식의 결과가 false라면 중괄호 영역 안으로 들어가지 않고 다음 코드를 순차적으로 실행한다

- 문법
	if(조건식){
		//조건식이 true일 때 실행할 문장;
	}

2) if~else문
	if~else : 만약 ~ 라면, 그렇지 않다면

	조건식의 결과가 true, false에 대해 각각의 분기를 만들어서 해당 중괄호 영역안으로 들어가 문장을 실행한다

- 문법
	if(조건식){
		//조건식의 결과가 true일 때 실행할 문장;
	} else {
		//조건식의 결과가 false일 때 실행할 문장;
	}

3) if ~ else if ~ else문
	조건식1의 결과가 true라면 if문 중괄호 영역 안의 문장을 실행
	조건식1의 결과가 false라면 else if문 조건식2를 확인한다
	조건식2의 결과가 true라면 else if문의 중괄호 영역 안의 문장을 실행
	false라면 그아래로 내려간다
	위의 조건식의 결과가 모두 false라면 else문 중괄호 영역 안의 문장을 실행

- 문법
	if(조건식1) {
		//조건식1이 true일 때 실행할 문장;
	} else if(조건식2){
		//조건식1이 false고 조건식2가 true일 때 실행할 문장;
	} else if(조건식3){
		//조건식 1과 조건식2가 false이고 조건식3이 true일 때 실행할 문장;
	} else{
		//모든 조건식의 결과가 false일 때 실행할 문장;
	}

- if문 : 조건문을 사용할 때 반드시 있어야 한다
- else if문 : 확인해야하는 조건식이 2개 이상일 경우 작성한다
- else문 : 위의 조건식이 모두 거짓일 때 작성한다

+) if ~ if 문, if ~ else if문
	if ~ if문은 모든 조건식을 확인한다
	if ~ else if문은 if문의 조건식을 확인 한 뒤 true라면 아래는 스킵(건너뜀)한다


	if(조건식){
	}
	if(조건식){
	}

	if(조건식){
		if(조건식){

		}
	}

+) if문의 중첩
	if문 안에 if문이 있는 것을 의미한다
	if(조건식1){
		if(조건식2){
			조건식1과 조건식2가 모두 true일 때 실행할 문장;
		}else{
			조건식1만 true일 때 실행할 문장;
		}
	}else{
		조건식1이 false일 때 실행할 문장;
	}
	

5. 조건문 - switch문
	조건식의 값에 따라서 여러 case 중 하나를 실행한다

	switch (변수명 or 값){
		case 값1:
			값1일 때 실행문;
			break;
		case 값2:
			값2일 때 실행문;
			break;
		case 값3:
			값3일 때 실행문;
			break;
		default:
			위 case들에 해당하는 것이 없을 때 실행문;
			break;
	}

- switch문에서 사용할 수 있는 타입 : byte, short, int, char, String, enum
- 사용할 수 없는 타입 : long, float, double, boolean

+) 삼항연산자, if문, switch문
- 삼항 연산자 : 조건식이 1개만 있을 경우
- if문 : 조건식에 논리연산자를 사용하거나 조건식이 2개 이상인 경우
- switch문 : 하나의 변수에 여러개의 값이 담길 수 있고 case의 값과 같은지를 비교할 때 사용

우리가 쓰는 java 버전은 17버전이다
지금 배운 switch 문법은 7 ~ 13버전의 문법이다
java 14 이상부터는 switch Expression(화살표 문법을 사용한다)

3일차 ~ 6일차 java 복습 문제(변수 ~ 조건문)

프로젝트명 : day06_task
패키지명 : basicTask01
클래스명 : 각 문제마다 제시

★ 문제1
한 곡당 300원인 코인 노래방이다.
사용자로부터 금액을 입력받아 부를 수 있는 곡 수와 잔돈을 출력하는 프로그램 작성하기

[입력 예시]
금액입력 : 1000

[출력 예시]
3곡을 부를 수 있으며 잔돈은 100원입니다

클래스명 : SingTask01


★ 문제2
문제1를 확장하여 한 곡당 가격도 사용자에게 입력받아 부를 수 있는 곡 수와 잔돈을 출력하는 프로그램 작성하기

[입력 예시]
금액입력 : 1000
곡 당 가격 입력 : 300

[출력 예시]
3곡을 부를 수 있으며 잔돈은 100원입니다

클래스명 : SingTask02


★ 문제3
문제 2를 확장하여 입력한 금액이 곡 당 가격보다 부족한 경우 노래를 부를 수 없다는 안내 문구를 출력하는 프로그램 작성하기

[입력 예시]
금액입력 : 100
곡 당 가격 입력 : 300

[출력 예시]
입력한 금액은 100원입니다.
곡 당 가격은 300원으로 200원이 부족하여 노래를 부를 수 없습니다

클래스명 : SingTask03

★ 문제4

한 곡당 가격은 200원, 음료 가격은 100원이다.
사용자로부터 금액을 입력받아 음료를 구매하지 않을 경우 부를 수 있는 곡 수와 잔돈 출력하기
음료를 구매할 경우 부를 수 있는 곡 수와 잔돈 출력하기

[입력 예시]
금액입력 : 1000

[출력 예시]
5곡을 부를 수 있으며 잔돈은 0원입니다
음료를 마시고 싶으면 4곡을 부를 수 있으며 잔돈은 100원입니다

클래스명 : SingTask04

[면담]
재민
명근
창표










































