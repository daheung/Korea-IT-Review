day14(java 12일차)

지각자 : 김성민(1시간), 윤철민(5분), 서정원(10분), 김유광(10분)
-----------------------------------------------------------------------------
복습 -> 캐스팅 -> 추상 클래스 -> 인터페이스

0. 복습
1) 상속
   단일 상속만 가능하다
   유지보수, 코드 재사용성, 확장성

- 상속 문법
   class 슈퍼클래스{
      //필드
      //생성자(오버로딩)
      //메소드(오버로딩)
      public 슈퍼클래스(int number){
         super();
         this.number = number;
      }
   }
   
   class 서브클래스 extends 슈퍼클래스{
      //슈퍼클래스의 필드와 메소드
      //서브클래스의 필드
      //서브클래스의 메소드(오버로딩, 오버라이딩)
      //서브클래스의 생성자(오버로딩)
      public 서브클래스의(int number){
         super(number);
      }
   }

- this, this(), super, super()
   this : 객체 자기자신(참조값)
   this() : 자기자신의 생성자
   super : 부모의 참조값
   super() : 부모의 생성자

2) enum 열거형
   고정된 값(상수)들을 나타내기 위한 특별한 데이터 유형
   클래스 타입(Reference Type)으로 취급된다

- enum 문법
   enum enum명 {   //enum 명의 첫문자는 대문자로 작성
      //상수
      //필드
      //생성자 접근제한자 private
      //메소드
   }

3) 다형성 특징
   - 오버로딩 : 매개변수의 개수, 순서, 타입이 다르면 같은 이름으로 선언할 수 있다
      생성자, 메소드
   - 오버라이딩 : 상속관계, 자식클래스에서 부모의 메소드를 구현부만 재정의해서 사용한다
      메소드

4) 접근제한자
         
   public      어디서나 접근 가능
         다른 패키지, 다른 클래스 모두 허용
         대표 클래스명, 필드, 메소드, 생성자
   protected   
   (defualt)
   private

1. Casting
   up casting : 자식 값을 부모 타입으로 형변환(자동 타입 변환)
      ex) 부모클래스타입 참조변수 = 자식타입객체;
   down casting : 이미 up casting된 객체를 자식 타입으로 형변환
      ★★★ 부모 참조값을 자식 타입으로 형 변환 시 오류발생
   

1) Up Casting
   자식 값을 부모 타입으로 형 변환(자동 형변환)
   부모타입 참조변수 = 자식타입객체;

   부모 클래스 타입의 참조 변수로 자식 클래스의 객체를 가리킬 수 있다
   업 캐스팅 후에는 부모 클래스의 멤버(필드, 메소드)에만 접근할 수 있다
   자식 클래스의 멤버는 참조할 수 없지만 객체 내부에는 여전히 자식 클래스의 멤버가 존재한다
   명시적 캐스팅 생략 가능

   부모클래스타입 참조변수 = (부모클래스타입) new 자식클래스생성자();
   부모클래스타입 참조변수 = (부모클래스타입) 자식객체;
   부모클래스타입 참조변수 = new 자식클래스생성자();
   부모클래스타입 참조변수 = 자식객체;

2) Down Casting
   이미 Up casting 된 객체를 자식 타입으로 형 변환
   ※ 부모 값을 자식 타입으로 형 변환시 오류 발생!!
   ※ 자식 클래스 타입의 객체는 부모 클래스 타입도 동시에 갖는다!!

   업 캐스팅 된 객체를 다시 자식 클래스타입으로 변환하는 것을 의미하며 명시적 캐스팅이 필요하다
   다운 캐스팅 후에는 자식 클래스의 멤버(필드, 메소드)에 접근할 수 있다
   잘못된 다운캐스팅(자식 타입의 객체에 부모 타입의 주소값(참조값)을 저장, 부모 객체를 자식 타입으로 변환시도)는
   ClassCastException 예외가 발생한다(실행해야 발생함)

3) Casting을 사용하는 이유
   부모타입인 하나의 저장공간에 여러 자식 타입의 참조값을 업캐스팅하여 저장할 수 있다(참조변수의 다형성)
   만약 하나의 기능을 하는 메소드를 만들 때 매개변수로 여러 자식 타입을 각각 받아야한다고 하면
   Casting이 없었다면 자식 타입을 매개변수로 받는 메소드를 타입별로 각각 만들어야한다(메소드 오버로딩을 활용)
   (자식별로 타입이 다르기 때문이다)
   Casting을 활용하면 부모 타입의 매개변수를 가진 메소드를 하나만 만들면 된다
   (부모 타입의 참조변수로 모든 자식 타입을 저장할 수 있기 때문이다)

※ 주의사항
   - 업 캐스팅 된 자식의 참조값을 저장했다면 자식 클래스에 오버라이딩 된 기능이 실행된다
   - 업 캐스팅 된 자식의 참조값을 저장했다면 자식 클래스에서 구현한 기능들은 사용할 수 없다
      이 경우 Down Casting을 통해서 복구하고 사용한다

4) 다형성
   하나의 것이 여러가지 형태를 가질 수 있는 성질
   - 오버로딩 : 생성자, 메소드
      같은 이름으로 매개변수의 타입, 순서, 개수가 다르면 선언할 수 있다
   - 오버라이딩 : 상속받은 자식 클래스의 메소드
      부모 클래스에 정의된 메소드 선언부를 그대로 쓰고 구현부만 재정의한다
      선언부는 무조건 똑같아야한다
   - 참조변수의 다형성(매개변수의 다형성) : 메소드 매개변수(상속 관계에서 부모 클래스 타입)
      부모 클래스 타입의 참조 변수로 자식 클래스 객체를 가리키는 것을 허용하는 것을 의미한다

5) 객체 간 타입 비교
   객체명 instanceof 클래스 타입
   a instanceof A : 조건식(참, 거짓 중 하나가 나오는 식)
      a가 A 클래스 타입이면 true
      a가 A 클래스 타입이 아니면 false