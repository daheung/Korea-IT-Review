day12
* 지각자 : 박지수
* 결석자 : 김성민

-----------------------------------------------------------------
복습 -> static -> 변수의 종류 ->  enum -> 테스트

0. 복습
1) 메소드
	하나의 기능을 하는 코드 블록

- 메소드 정의
	반환타입 메소드명(자료형 매개변수){
		실행문;
		return 리턴값;
	}

- 가변길이 매개변수
	리턴타입 메소드명(자료형 ... 매개변수){
		실행문;
		return 리턴값;
	}

	void method1(){
		syso("안녕하세요");
	}
	
	void method1(String name){
		syso(name + "님 안녕하세요");
	}
	
	String method1(){
		return "김영선";
	}

	int method1(int num){
		return num;
	}


- 메소드 호출방법 4가지
	Test t = new Test();	

	매개변수 x 리턴값 x		객체명.메소드명();
				t.method1();	

	매개변수 o 리턴값 x		객체명.메소드명(인수);
				t.method1("홍길동");
				
	매개변수 x 리턴값 o		syso(객체명.메소드명());
				syso(t.method1());

	매개변수 o 리턴값 o		자료형 변수명 = 객체명.메소드명(인수);
				int num = t.method1(5);

2) 클래스
	사용자 정의 타입으로 필드와 메소드를 묶어서 관리할 수 있는 설계도
	
- 클래스 선언
	class 클래스명 {
		//필드;
		//메소드(){}
		//생성자(){}
	}

- 객체화(인스턴스화)
	클래스타입 참조변수 = new 생성자();

- 클래스 멤버에 접근
	객체명.필드명;	//해당 객체의 고유한 값(특징, 속성)으로 사용
			//필드 자료형에 맞는 기본값
	객체명.필드명 = 값;	//해당 객체의 고유한 값을 대입

	객체명.메소드명();	//매개변수x, 리턴값x 메소드 호출

3) 생성자(constructor)
	클래스의 이름 뒤에 소괄호가 있는 형태
	생성자는 리턴이라는 기능이 존재하지 않는다
	객체가 생성될 때 자동으로 실행되며 주로 클래스의 필드를 초기화하는데 사용된다

- 기본 생성자
	public 클래스명(){
		
	}

- 매개변수가 있는 생성자
	public 클래스명(자료형 매개변수){
		this.필드명 = 매개변수;
	}

4) this, this()
	this : 객체 자기 자신(참조값)
	this() : 자기자신의 생성자, 생성자 내에서 가장 최상단에 작성

	class Test {
		//필드
		String name;

		//생성자
		public Test(String name){
			this.name = a;
		}
		
		//메소드
		void method1(String name){
			syso(name + "님 안녕하세요");
		}
	

	}
	
	public class Main{
		main(String[] args){
			Test t = new Test("홍길동");
			syso(t.name);	//홍길동
			t.method1("짱구");	//짱구님 안녕하세요
		}
	}

5) 필드와 지역변수의 차이
	지역변수는 메소드, 생성자 블록에서 선언되고 메소드와 생성자 호출 시에만 생성되고 사용된다
	필드는 클래스 블록에서 선언되고 객체 내부에서 존재하고 객체 내부, 외부에서 사용가능하다

	구분	필드			지역변수
	선언위치	클래스 선언 블록		생성자, 메소드 선언 블록
	존재위치	객체 내부에서 존재		생성자, 메소드 호출 시에만 존재
	사용위치	객체 내,외부 어디든사용	생성자, 메소드 블록 내부에서만 사용

1. static
	정적인
	프로그램이 시작되면 생성되고 프로그램이 종료될때까지 유지된다
	프로그램이 실행되는 동안 계속해서 유지되는 저장공간

1) 정적 멤버(Static Member)
	정적 멤버는 클래스 자체에 속하는 멤버, 클래스를 통해서 접근
	객체를 생성하지 않아도 사용할 수 있다
	정적 변수와 정적 메소드가 포함된다

- 정적 변수 : 클래스의 모든 인스턴스(객체)에서 동일한 값을 공유, 객체간의 정보 공유에 사용된다
- 정적 메소드 : 객체를 생성하지 않아도 호출 가능하고 주로 유틸리티 메소드나 공통 동작을 구현하는데 사용된다

2) 멤버변수와 멤버 메소드의 종류
	static이 붙은 변수 : static 변수, 클래스변수, 정적변수
	static이 붙지 않은 변수 : 인스턴스 변수

	static이 붙은 메소드 : static 메소드, 클래스 메소드, 정적 메소드
	static이 붙지 않은 메소드 : 인스턴스 메소드

3) static 변수와 static 메소드
	static 변수, static 메소드는 객체를 생성하지 않아도 클래스 이름을 통해 직접 사용할 수 있다
	객체의 생성과는 무관하게 클래스 로딩시에 메모리에 올라가며 프로그램이 실행되는 동안 유지된다

	static 변수는 객체와 상관없이 하나의 저장공간이므로 모든 객체가 공유해서 사용한다
	즉, 모든 객체에 공통으로 사용되는 변수에 static 붙이는 것을 고려한다

	static 메소드는 인스턴스 멤버를 직접 사용할 수 없다
	static 메소드가 메모리에서 사용할 준비가 끝나도 인스턴스 멤버는 new를 사용하여 객체를 생성하기 전까지
	사용할 수 없기 때문이다

+) 정적변수는 클래스 수준에서 선언되며 클래스의 모든 객체간에 공유되는 변수이다
	한 번 메모리에 할당되면 프로그램이 실행중일 때 항상 존재하며 수정이 가능하다
	클래스가 처음 사용되거나 정적 멤버에 접근하면 해당 클래스가 메모리에 로드되고
	클래스의 정적변수 및 정적 메소드가 method 영역에 할당되는데 이 과정을 클래스 로딩이라고 한다
	정적변수의 변경은 해당 클래스의 모든 객체에 영향을 끼친다
	method 영역은 가비지컬렉션의 영향을 받지 않는다
	객체가 해제되더라도 method영역에 할당된 데이터는 프로그램의 종료까지 유지된다

+) JVM의 메모리 영역
(1) Method 영역(메소드 영역, Class Area)
	클래스 단위 정보가 저장되는 영역
- 저장내용
	클래스 메타데이터(클래스명, 패키지, 메소드 정보, 필드 정보), static 변수, static 메소드, 상수 풀(Constant Pool)

- 특징
	클래스 로더(Class Loader)가 클래스를 로드할 때 생성
	프로그램 시작시 생성, 종료시까지 유지
	모든 객체와 모든 쓰레드가 공유
	클래스당 한번만 로딩

- 참고
	java8 이후 Method영역이 아닌 Metaspace로 구현됨
		heap이 아닌 OS 메모리 사용


(2) Heap 영역
	객체가 저장되는 공간

- 저장 내용
	new 키워드로 생성된 객체
	객체의 인스턴스 변수(필드)

- 특징
	객체마다 독립적인 공간
	모든 쓰레드가 공유
	Garbage Collector(GC)가 자동 관리
	프로그램 실행 중 동적으로 크기 변경 가능

(3) Stack 영역
	메소드 실행과 관련된 데이터 저장

- 저장 내용
	지역변수, 매개변수, 메소드 호출 정보, 리턴주소

- 특징
	쓰레드마다 하나씩 생성(Thread Local)
	메소드 호출 시 => 스택 프레임 생성
	메소드 종료 시 => 스택 프레임 제거
	LIFO(후입선출)구조

(4) PC Register(Program Counter Register)
	현재 실행중인 명령어 위치를 저장

- 역할
	각 쓰레드가 지금 실행 중인 JVM 명령어 주소를 기억
	멀티 쓰레드 환경에서 문맥교환(Context Switching) 시 필수

- 특징
	쓰레드마다 하나씩 존재
	매우 작은 메모리
	Native 메소드 실행시에는 값이 undefined

(5) Native Method Stack(네이티브 메소드 스택)
	Java가 아닌 코드 실행을 위한 스택

- 사용 시점
	native 키워드가 붙은 메소드 호출 시
	C, C++ 등으로 작성된 코드 실행

- 특징
	쓰레드마다 하나씩 존재
	일반 Stack 영역과 역할은 유사하지만 JVM 외부 코드 실행용

+) 	static -> Method 영역
	new -> Heap 영역
	지역변수 -> Stack 영역
	Stack은 쓰레드별 / Heap 공유
	GC는 Heap만 관리


영역		저장내용			공유여부	관리주체
Method		클래스정보, static		공유	JVM
Heap		객체, 인스턴스변수		공유	GC
Stack		지역변수, 호출정보		쓰레드별	JVM
PC레지스터		실행 명령 주소		쓰레드별	JVM
Native Stack	네이티브 메소드		쓰레드별	JVM

4) 정적 블록
	클래스가 로드될 때 실행되는 블록
	주로 정적 멤버를 초기화할 때 사용
	모든 인스턴스가 생성되기 전에 실행되므로 초기화 작업에 유용하다

- 로드 시점 : 클래스가 처음 로드될 때 실행되며 클래스가 메모리에 로드되는 시점
	클래스의 객체가 생성될 때(클래스 인스턴스화)
	클래스의 정적멤버(변수 또는 메소드)에 접근할 때
	클래스를 사용하는 다른 클래스가 로드될 때(참조하려는 클래스에 의존성이 있는 경우)

static {

}

2. 변수의 종류
	지역변수(local variable)
		클래스의 중괄호 영역은 포함되지 않으며, 메소드나 또는 그 안의 중괄호 영역에서 선언된 변수
	매개변수(parameter)
		메소드의 소괄호 안에서 선언된 변수(지역변수와 마찬가지로 해당 메소드 안에서만 사용가능하다)
	인스턴스변수(instance variable)
		클래스 중괄호 영역에서 선언된 변수
	정적변수(static variable, class variable)
		static 붙은 변수, 객체 간 공유, 편의성

3. enum 열거형
	일련의 고정된 값(상수)들을 나타내기 위한 특별한 데이터 유형

1) enum 사용하는 이유
	코드의 가독성과 안정성 향상
	컴파일 타입 오류 방지
	관련 데이터와 동작을 묶을 수 있음

2) 문법
	enum Day {
		MONDAY, TUESDAY, WEDNESEDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
	}

	Day today = Day.THURSDAY;

	if(today == Day.THURSDAY){
		syso("목요일입니다");
	}

3) 특징
	enum은 클래스이다
		java.lang.Enum 을 상속
		객체처럼 동작
	타입 안정성(Type Safety) 제공
		다른 enum 타입과 비교 불가
	메소드, 생성자, 필드 정의 가능
	
+) 특징
	enum에 선언된 값은 상수 객체로 각 값은 컴파일 시점에 고유한 인스턴스로 생성된다
	값의 순서는 0부터 시작하며 순서를 정수로 얻으려면 ordinal() 메소드를 사용한다
	
	열거형 배열
		values() 모든 열거형 값을 배열로 얻을 수 있다
	name(), valueOf()
		name() 		열거형 이름(문자열)을 반환
		valueOf()	문자열을 열거형 값으로 반환

4. final
	최종적인, 마지막의 의미

	final 변수	상수(값 변경불가)
	final 메소드	오버라이딩 불가(재정의 불가)
	final 클래스	상속 불가

-----------------------------------------------------------------------------------------
클래스 상속 전까지 복습

출력메소드
	System.out.println()
	System.out.print()
	System.out.printf("%d %s %f", 10, "s", 3.14)
	=> 10 s 3.140000

변수
	하나의 자료형, 하나의 값을 저장하는 저장공간
	자료형 변수명 = 값;

	지역변수		생성자, 메소드 또는 그 안의 영역에서 사용하는 변수
	매개변수		생성자, 메소드 소괄호에서 사용하는 변수
	인스턴스 변수	객체마다 고유한 값을 가지는 변수 	객체명.변수명
	정적변수		모든 인스턴스가 공유하는 값을 가지는 변수 	클래스명.변수명

자료형
	정수형	byte, short, int, long
	실수형	double, float
	논리형	boolean
	문자형	char

	문자열	String
	배열	int[]	String[][]
	클래스	Person

입력메소드
	Scanner sc = new Scanner(System.in);

	.nextLine();
	.next();
	.nextInt();
	.nextDouble();

	.close();

연산자
	최
	단
	산
	쉬
	관
	리
	삼
	대

제어문
	조건문	if, switch
	반복문	for, while, do~while, for-each
	기타제어문	break, continue, return;

배열
	하나의 자료형으로 여러가지 값을 저장할 수 있는 저장공간
	heap 메모리에 저장공간이 만들어지고 stack 메모리에는 참조변수가 저장된다
	참조변수에는 참조값이 들어간다

	- 값을 모르고 칸수만 알 때
	자료형[] 참조변수 = new 자료형[배열길이];
	- 값을 알 때
	자료형[] 참조변수 = {값1, 값2, 값3};
	- 현재 몇칸만들지, 어떤값이 들어갈지 모르지만 배열이 필요할 때
	자료형[] 참조변수 = null;
	참조변수 = new 자료형[]{값1, 값2};
	
	- 값을 모르고 칸수만 알 때
	자료형[][] 참조변수 = new 자료형[행][열];
	- 값을 알 때
	자료형[][] 참조변수 = {{값1}, {값2, 값3}};
	- 현재 몇칸만들지, 어떤값이 들어갈지 모르지만 배열이 필요할 때
	자료형[][] 참조변수 = null;

메소드
	하나의 기능(행위, 동작)을 수행하는 코드의 묶음
	코드의 재사용성, 모듈화, 가독성, 유지보수성 높이기 위해 사용


- 인스턴스 메소드
	리턴타입 메소드명(자료형 매개변수){
		실행문;
		return 리턴값;
	}
	
호출방법
	클래스 객체명 = new 생성자();
	객체명.메소드명();		매개변수x 리턴값x
	객체명.메소드명(인수);	매개변수o 리턴값x
	syso(객체명.메소드명());	매개변수x 리턴값o
	syso(객체명.메소드명(인수));	매개변수o 리턴값o

- 정적 메소드
	static 리턴타입 메소드명(자료형 매개변수){
		실행문;
		return 리턴값;
	}

	클래스명.메소드명();		매개변수x 리턴값x
	클래스명.메소드명(인수);	매개변수o 리턴값x
	자료형 변수 = 클래스명.메소드명();	매개변수x 리턴값o
	자료형 변수 = 클래스명.메소드명(인수);	매개변수o 리턴값o
	
	메소드/생성자 오버로딩
		리턴타입은 상관없음
		같은 이름으로 매개변수의 타입, 개수, 순서가 다르면 정의할 수 있다
	
클래스
	사용자 정의 자료형
	객체를 만들기 위한 틀(설계도)
	공통되는 속성(필드)과 기능(메소드)을 한 곳에 모아 관리할 수 있음
	
	class 클래스명{
		//필드
		//생성자
		//메소드
	}

	객체화(인스턴스화)
	클래스명 참조변수 = new 생성자();

생성자
	객체를 생성하면서 필드의 값을 초기화 할 때 사용
	생성자를 만들지 않으면 컴파일러가 기본생성자를 만듦
	
	public 클래스명(){

	}

static
	static 변수 : 스태틱변수, 정적변수, 클래스변수
	static 메소드 : 스태틱메소드, 정적메소드, 클래스메소드

this, this()
	this : 객체 자기자신(참조값)
	this() : 자기자신의 생성자, 생성자 안에서만 호출, 최상단에 작성해야한다

enum
	열거형
	서로 관련된 상수들을 하나의 타입으로 묶은 것
	값의 범위를 제한하여 오류를 줄이고 가독성을 높임
	java에서는 클래스처럼 동작
	enum 상수는 객체다 => 각 상수는 하나의 객체, JVM이 클래스 로딩 시 자동 생성
	
	public static final	=> 자동으로 포함되는 키워드

	Day.MONDAY


	public static final Day MONDAY = new Day();
	객체 수 고정
	타입 안정성 보장
	싱글톤 패턴과 유사

enum과 static final 상수 차이
		enum		static final
타입		독립된 타입	단순 상수
타입안정성		o		x
객체 개수		고정		제한 없음
switch사용 	o		제한적
메소드포함		o		x
---------------------------------------------------------------------------------
5. 상속(inheritance)
	기존 클래스의 멤버(필드, 메소드)를 재사용하고 필요한 기능만 추가하여 새로운 클래스를 만드는 방식
	여러 클래스 선언시 멤버가 겹치는 경우, 부모클래스를 먼저 선언하고 공통 멤버를 자식 클래스에게 상속해주는 개념

1) 상속 문법
	class Parents{
		//Parents 클래스의 멤버
	}

	class Child extends Parents{
		//Parents 클래스의 멤버
		//Child 클래스의 멤버
	}

	Parents : 부모클래스, 슈퍼클래스, 기반클래스, 상위클래스
	Child : 자식클래스, 서브클래스, 파생클래스, 하위클래스

	※ 자바에서 상속은 단일 상속만 지원한다

2) 상속을 사용하는 이유
	공통된 멤버를 부모 클래스에 두고 자식 클래스에서 재사용하기 위해
	중복코드 제거, 유지보수성 향상, 객체지향성 설계 가능



























